[{"title":"Linux下安装redis踩坑","date":"2019-10-15T01:59:48.000Z","path":"2019/10/15/Linux下安装redis踩坑/","text":"环境：virtualbox+ubuntu-18.04.3安装redis:下载：wget http://download.redis.io/releases/redis-4.0.14.tar.gz解压：tar -xzf redis-4.0.14.tar.gz创建软连接：ln -s redis-4.0.14 redis进入redis目录并编译与安装：123cd redis sudo make sudo make install 若在编译时报错提示无make命令，则需安装make：sudo apt-get install make 若出现以下错误：123456789cd src &amp;&amp; make allmake[1]: Entering directory '/home/ubuntu/redis-4.0.11/src' CC adlist.o/bin/sh: 1: cc: not foundMakefile:228: recipe for target 'adlist.o' failedmake[1]: *** [adlist.o] Error 127make[1]: Leaving directory '/home/ubuntu/redis-4.0.11/src'Makefile:6: recipe for target 'all' failedmake: *** [all] Error 2 则需安装gcc:sudo apt-get install gcc 若出现以下错误: 123456789cd src &amp;&amp; make allmake[1]: Entering directory '/home/ubuntu/redis-4.0.11/src' CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; ^~~~~~~~~~~~~~~~~~~~~compilation terminated.Makefile:228: recipe for target 'adlist.o' failed 解决方法:用make MALLOC=libc来替代make命令 若出现以下错误：12You need tcl 8.5 or newer in order to run the Redis testmake: *** [test] Error 1 则需安装tcl:1234wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz sudo tar xzvf tcl8.6.1-src.tar.gz -C /usr/local/ cd /usr/local/tcl8.6.1/unix/ sudo ./configure","tags":[]},{"title":"BCNF","date":"2019-03-21T14:30:46.000Z","path":"2019/03/21/BCNF/","text":"1.所有非主属性对每一个候选键都是完全函数依赖； 2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； 3.没有任何属性完全函数依赖于非候选键的任何一组属性。","tags":[]},{"title":"ff","date":"2019-03-12T05:24:46.000Z","path":"2019/03/12/ff/","text":"","tags":[]},{"title":"模板之拓扑排序&优先队列","date":"2019-03-12T03:49:18.000Z","path":"2019/03/12/模板题之拓扑排序-优先队列/","text":"代码模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#define maxv 1010using namespace std;vector&lt;int&gt; G[maxv];vector&lt;int&gt; res;int n,m,inDegree[maxv],num=0;bool ts()&#123; num=0; priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; q; for(int i=0;i&lt;n;i++)&#123; if(inDegree[i]==0)&#123; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.top(); res.push_back(u); q.pop(); for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; inDegree[v]--; if(inDegree[v]==0)&#123; q.push(v); &#125; &#125; // G[u].clear(); num++; &#125; if(num==n) return true; else return false;&#125;int main()&#123; for(int i=0;i&lt;maxv;i++)&#123; inDegree[i]=0; &#125; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G[a].push_back(b); inDegree[b]++; &#125; if(ts())&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; int i; for(i=0;i&lt;res.size()-1;i++)&#123; cout&lt;&lt;res[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;res[i]; &#125;else&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; cout&lt;&lt;n-num; &#125; &#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cloudqht.github.io/tags/数据结构/"}]},{"title":"求字符串最长重复串模板","date":"2019-03-05T07:07:03.000Z","path":"2019/03/05/求字符串最长重复串模板/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void radix(int * str, int *a, int *b, int n, int m)&#123; static int count[MAX]; memset(count,0,sizeof(count)); for(int i = 0; i &lt; n; ++i) ++count[str[a[i]]]; for(int i = 1; i &lt;= m; ++i) count[i] += count[i-1]; for(int i = n -1; i &gt;= 0; --i) b[--count[str[a[i]]]] = a[i];&#125; void suffix_array(int* str,int * sa, int n, int m)&#123; static int rank[MAX],a[MAX],b[MAX]; for(int i = 0; i &lt; n; ++i) rank[i] =i; radix(str,rank,sa,n,m); rank[sa[0]] = 0; for(int i = 1; i &lt; n; ++i) rank[sa[i]]= rank[sa[i-1]] +(str[sa[i]]!=str[sa[i-1]]); for(int i = 0; 1&lt;&lt;i&lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; a[j] = rank[j]+1; b[j] = j + (1&lt;&lt;i) &gt;=n? 0: rank[j + (1&lt;&lt;i)] + 1; sa[j] = j; &#125; radix(b,sa,rank,n,n); radix(a,rank,sa,n,n); rank[sa[0]] = 0; for(int j = 1; j &lt; n; ++j)&#123; rank[sa[j]] = rank[sa[j-1]] + (a[sa[j-1]] != a[sa[j]] || b[sa[j-1]] != b[sa[j]]); &#125; &#125;&#125; int duplicate_substr(string str)&#123; string rev; static int s[MAX],sa[MAX],rank[MAX],h[MAX]; int n = str.length(); copy(str.begin(),str.end(),s); suffix_array(s,sa,n,256); for(int i = 0 ; i &lt; n; ++i) rank[sa[i]] = i; int k = 0; int ans1 =0,pos1 = 0; for(int i = 0; i &lt; n; ++i)&#123; k = k==0? 0: k - 1; while(rank[i] &gt; 0 &amp;&amp; s[i + k] == s[sa[rank[i] - 1] + k]) ++k; h[rank[i]] = k; if(h[rank[i]] &gt; ans1)&#123; ans1 = h[rank[i]]; pos1 = i; &#125; &#125; return str.substr(pos1,ans1).length();&#125; 用的时候直接调用duplicate_substr()，传入字符串即可","tags":[{"name":"字符串","slug":"字符串","permalink":"https://cloudqht.github.io/tags/字符串/"}]},{"title":"git常用命令","date":"2019-02-17T04:17:38.000Z","path":"2019/02/17/git常用命令/","text":"1234567891011121314151617181920212223242526git init //初始化本地git环境git clone XXX//克隆一份代码到本地仓库git pull //把远程库的代码更新到工作台git pull --rebase origin master //强制把远程库的代码跟新到当前分支上面git fetch //把远程库的代码更新到本地库git add . //把本地的修改加到stage中git commit -m 'comments here' //把stage中的修改提交到本地库git push //把本地库的修改提交到远程库中git branch -r/-a //查看远程分支/全部分支git checkout master/branch //切换到某个分支git checkout -b test //新建test分支git checkout -d test //删除test分支git merge master //假设当前在test分支上面，把master分支上的修改同步到test分支上git merge tool //调用merge工具git stash //把未完成的修改缓存到栈容器中git stash list //查看所有的缓存git stash pop //恢复本地分支到缓存状态git blame someFile //查看某个文件的每一行的修改记录（）谁在什么时候修改的）git status //查看当前分支有哪些修改git log //查看当前分支上面的日志信息git diff //查看当前没有add的内容git diff --cache //查看已经add但是没有commit的内容git diff HEAD //上面两个内容的合并git reset --hard HEAD //撤销本地修改echo $HOME //查看git config的HOME路径export $HOME=/c/gitconfig //配置git config的HOME路径","tags":[{"name":"git常用命令","slug":"git常用命令","permalink":"https://cloudqht.github.io/tags/git常用命令/"}]},{"title":"BFS&DFS","date":"2018-10-04T15:50:28.000Z","path":"2018/10/04/BFS-DFS/","text":"BFS（Breadth-First-Search,广度优先搜索)123456789101112131415161718192021222324bool visited[MAX_VERTEX_NUM];void BFSTraverse(Graph G)&#123; for(i=0;i&lt;G.vexnum;i++)&#123; visited[i]=FALSE; &#125; InitQueue(Q); for(i=0;i&lt;G.vexnum;i++) if(!visited[i]) BFS(G,i);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v]=TRUE; Enqueue(Q,v); while(!isEmpty(Q))&#123; Dequeue(Q,v); for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,V,W))&#123; if(!isvisited(w)) visit(w); visited[w]=TRUE; Enqueue(Q,w); &#125; &#125;&#125; DFS（Depth-First-Search,深度优先搜索)12345678910111213141516bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G)&#123; for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; for(v=0;v&lt;G.vexnum;++v) if(!visited[v]) DFS(G,v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v]=TRUE; for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))&#123; if(!visited[w]) DFS(G,w); &#125;&#125;","tags":[{"name":"图","slug":"图","permalink":"https://cloudqht.github.io/tags/图/"}]},{"title":"二叉排序树及其进化（平衡二叉树）","date":"2018-09-26T15:14:33.000Z","path":"2018/09/26/二叉排序树及其进化（平衡二叉树）/","text":"二叉排序树（二叉查找树）特点：左子树值&lt;结点值&lt;右子树值，其中序遍历序列为递增有序序列 二叉排序树的插入二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。123456789101112131415int BST_Insert(BiTree &amp;T, KeyType k)&#123; if(T==NULL)&#123; T=(BiTree)malloc(sizeof(BSTNode)); T-&gt;key=k; T-&gt;lchild=NULL; T-&gt;rchild=NULL; return 1; &#125; else if(k==T-&gt;key) return 0; else if(k&lt;T-&gt;key) return BST_Insert(T-&gt;lchild, k); else return BST_Insert(T-&gt;rchild, k);&#125; 二叉排序树的建立12345678void Create_BST(BiTree &amp;T, KeyType str[], int n)&#123; //用关键字数组str[]建立一个二叉排序树 int i=0; T=NULL; while(i&lt;n)&#123; BST_Insert(T,str[i++]); &#125;&#125; 二叉排序树的非递归查找(类比线性表的二分查找)123456789101112//查找函数返回指向关键字值为key的结点指针，若不存在则返回NULLBSTNode *BST_Search(BiTree T, Elemtype key, BSTNode *&amp;p)&#123; p=NULL; //p指向被查找结点的双亲，用于插入或删除操作 while(key!=T-&gt;data&amp;&amp;T!=NULL)&#123; p=T; if(key&lt;T-&gt;data) T=T-&gt;lchild; else T=T-&gt;rchild; &#125; return T;&#125; 判断给定的二叉树是否是二叉排序树中序遍历序列为递增有序序列的二叉树即为二叉排序树。123456789101112131415KeyType predt=-65535;int JudgeBST(BiTree T)&#123; int b1,b2; if(T==NULL) return 1; else&#123; b1=JudgeBST(T-&gt;lchild); if(b1==0||T-&gt;data&lt;predt) return 0; predt=T-&gt;data; b2=JudgeBST(T-&gt;rchild); return b2; &#125;&#125; 平衡二叉树平衡二叉树是二叉排序树的演变与进化。 二叉排序树在结点插入的顺序不同时，性能可能有所不同。 举个极端例子，当用一个顺序序列建立二叉排序树时，结点的数量等于二叉树的高。此时查询一个结点的时间复杂度与单链表相同，为O(n)。这与我们想要的时间复杂度O($\\log_2 n$)相距甚远。 由于二叉排序树的性能与其高度息息相关，为避免出现性能下降的情况，则在插入结点时要充分利用其高度，避免其增长过快。由此，平衡二叉树诞生了。 平衡二叉树（AVL树）保证在插入和删除结点后，二叉树任意节点的左、右子树高度差绝对值不超过1。定义结点左右子树的高度差为结点的平衡因子。","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"完全二叉树的鉴别","date":"2018-09-26T10:38:52.000Z","path":"2018/09/26/完全二叉树的鉴别/","text":"利用完全二叉树的性质鉴别完全二叉树的1-n结点与满二叉树相同123456789101112131415161718192021bool isComplete(BiTree T)&#123; if(!T) return 1; //空二叉树为完全二叉树 InitQueue Q; BiTree p; EnQueue(Q,T); while(!IsEmpty(Q))&#123; DeQueue(Q,p); if(p)&#123; EnQueue(Q,p-&gt;lchild); EnQueue(Q,p-&gt;rchild); &#125;else&#123; while(!IsEmpty(Q))&#123; DeQueue(Q,p); if(p) return 1; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"二叉树的建立","date":"2018-09-25T15:56:19.000Z","path":"2018/09/25/二叉树的建立/","text":"由先序遍历序列和中序遍历序列确定二叉树1234567891011121314151617181920212223242526272829//A,B数组存放先序和中序结点的data//l1,l2,h1,h2分别为先序和中序的第一和最后一个结点下标BiTree PreInCreate(Elemtype A[], Elemtype B[], l1, h1, l2, h2)&#123; //建立根节点 BiTNode root = new BiTNode; //c写法为(BiTNode*)malloc(sizeof(BiTNode)); root-&gt;data=A[l1]; //找到先序遍历头结点A[l1]结点在中序遍历中的位置 for(int i=l2;B[i]!=root-&gt;data;i++); //左右子树长度 int llen=i-l2; int rlen=h2-i; //递归建立左右子树，若len=0,则左右结点置为NULL if(llen) root-&gt;lchild=PreInCreate(Elemtype A[], Elemtype B[], l1+1, l1+llen, l2, l2+llen-1); else root-&gt;lchild=NULL; if(rlen) root-&gt;rchild=PreInCreate(Elemtype A[], Elemtype B[], h1-rlen+1, h1, h2-rlen+1, h2); else root-&gt;rchild=NULL; return root; &#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"二叉树的遍历","date":"2018-09-23T13:50:18.000Z","path":"2018/09/23/二叉树的遍历/","text":"后序遍历 后序非递归遍历利用栈进行非递归遍历。算法思想：因为后序非递归遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根结点，用堆栈存储结点，必须分清返回根结点时，是从左子树返回的，还是从右子树返回的。故要使用辅助指针 r，其指向最近访问过的结点。 1234567891011121314151617181920212223void PostOrder(Bitree T)&#123; InitStack(S); p=T; r=NULL; //标志指针 while(p||!isEmpty(S))&#123; if(p)&#123; //走到最左边 push(S,p); //结点入栈 &#125;else&#123; GetTop(S,p); //取栈顶结点 if(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123; p=p-&gt;rchild; //转向右 push(S,p); p=p-&gt;lchild; //再向左 &#125;else&#123; pop(S,p); visit(p); r=p; //指向最近访问的结点 p=NULL; &#125; &#125;//else &#125;//while&#125; 通过遍历求二叉树的高 （非递归）通过队列进行层次遍历求二叉树的高12345678910111213141516171819202122//当level+1时，出队结点front结点正好是该层的最右结点， //而且此时rear结点为下层的最右结点。因为front结点右孩子就是rear结点 int Btdepth1(BiTree T)&#123; int level=0,rear=-1,front=-1; int last=0; //标志尾指针即二叉树本层的最右结点 BiTree Q[MaxSize], p; Q[++rear]=T; while(front&lt;rear)&#123; p=Q[++front]; if(p-&gt;lchild!=NULL)&#123; //若有左右子树，将左右子结点入队 Q[++rear]=p-&gt;lchild; &#125; if(p-&gt;rchild!=NULL)&#123; Q[++rear]=p-&gt;rchild; &#125; if(front==last)&#123; //出队结点正好是层次遍历该层的最右结点，则level+1 level++; last=rear; //last结点重新指向下层的最右结点 &#125; &#125;&#125; 递归方法求二叉树的高1234567891011int Btdepth2(BiTree T)&#123; if(T==NULL) return 0; int ldep=Btdepth2(T-&gt;lchild); int rdep=Btdepth2(T-&gt;rchild); if(ldep&gt;rdep) return ldep+1; else return rdep+1; &#125; 判断是否是小根堆123456789101112131415161718192021//将顺序表L[1...n]看成一个完全二叉树，扫描所有分支结点，当遇到孩子结点的关键字小于根节点关键字返回false,扫描完则返回true.bool IsMinHeap(ElemType A[], int len)&#123; //判断是否有单分支结点 if(len%2==0)&#123; //小根堆特点：双亲结点小于子结点，子结点顺序随意，此处len/2为双亲结点，len结点为子结点 if(A[len/2]&gt;A[len])&#123; return false; &#125; else&#123; for(i=len/2-1;i&gt;0;i--) if(A[i]&gt;A[i*2]||A[i]&gt;A[i*2+1]) return false; &#125; &#125; else&#123; for(i=len/2;i&gt;0;i--) if(A[i]&gt;A[i*2]||A[i]&gt;A[i*2+1]) return false; &#125; return true;&#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"栈与队列","date":"2018-09-22T12:04:22.000Z","path":"2018/09/22/栈与队列/","text":"栈 顺序栈 定义:123456#define MaxSize 50; typedef struct&#123; int top; Elemtype data[MaxSize]; &#125;SqStack;","tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"https://cloudqht.github.io/tags/栈与队列/"}]}]