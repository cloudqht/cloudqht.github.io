[{"title":"杀手·价值连城的幸运","date":"2022-04-05T14:21:07.000Z","path":"2022/04/05/杀手·价值连城的幸运/","text":"幸运之神啊，虽然我已放弃了爱情，但，如果还能反悔的话，请保佑我明天下午有一场幸福美好的约会。 寂寞的人，怕的不是寂寞。而是不知不觉习惯了孤独。 过几年，他会慢慢忘记他需要交一个女朋友。 再过几年，床底下的蝉堡就会厚得像一本字典。 再过得了几年，如果没有被杀死，他会成为一个杀手传奇。然后很寂寞。 寂寞到，只是杀人再也不够了。","tags":[{"name":"小说","slug":"小说","permalink":"https://cloudqht.github.io/tags/小说/"}]},{"title":"聊天演进","date":"2022-04-05T13:20:12.000Z","path":"2022/04/05/聊天演进/","text":"我可能是一个没有多少内涵的人聊多了乏味无话可说各个领域谈完了不想重复如何解决应该是解决不了解决不了就被动一点吧可能停一阵子更有助于放弃不切实际的幻想回到以前的生活方式吧，无缘注定无缘","tags":[{"name":"心路历程","slug":"心路历程","permalink":"https://cloudqht.github.io/tags/心路历程/"}]},{"title":"放弃不切实际的幻想","date":"2022-04-05T02:30:55.000Z","path":"2022/04/05/放弃不切实际的幻想/","text":"只是特殊时期的特殊情况罢了不要多想换一个人会有不同吗，大概率是没有享受当下珍惜这样的体验放弃不切实际的幻想","tags":[{"name":"心路历程","slug":"心路历程","permalink":"https://cloudqht.github.io/tags/心路历程/"}]},{"title":"xszk-初级阶段","date":"2022-03-27T11:57:35.000Z","path":"2022/03/27/xszk-初级阶段/","text":"谢谢你让我爱过你-S.H.E感觉天气冷了就加件毛衣 而不是急着躲进某个人的怀里 这种简单的快乐我竟然忘记 直到你离去才恢复记忆 还可以呼吸心跳也还规律 只除了寂寞它还不肯马上就平息 相恋和失恋如果说都需要练习 一次学会两种也算好事情 谢谢你教会我爱需要两颗心 谢谢你示范了什么人该放弃 谢谢你提醒我痛会唤醒勇气 谢谢你曾让我这样的爱过你 只要睁开眼睛就有好风景 再不用苦苦等你偶尔的好心情 这种简单的快乐比玫瑰美丽 我相信伤心会慢慢痊愈 还可以呼吸心跳也还规律 只除了寂寞它还不肯马上就平息 相恋和失恋如果说都需要练习 一次学会两种也算好事情 谢谢你教会我爱需要两颗心 谢谢你示范了什么人该放弃 谢谢你提醒我痛会唤醒勇气 谢谢你曾让我这样的爱过你 谢谢你教会我爱需要两颗心 谢谢你示范了什么人该放弃 谢谢你提醒我痛会唤醒勇气 谢谢你曾让我这样的爱过你 xszk这种奇妙的感觉…念头不时在大脑里出现，今日记录一下。非常奇妙的体验，但应该是没有可能了…这就是人生吧，感谢。","tags":[{"name":"心路历程","slug":"心路历程","permalink":"https://cloudqht.github.io/tags/心路历程/"}]},{"title":"gitee ssh key algorithm problem","date":"2021-10-30T16:45:05.000Z","path":"2021/10/31/gitee-ssh-key-algorithm-problem/","text":"更换秘钥生成算法，使用 ed25519 算法生成ssh-keygen -t ed25519 -C “your email”","tags":[]},{"title":"","date":"2021-10-30T16:40:37.053Z","path":"2021/10/31/回溯算法/","text":"title: 回溯算法date: 2019-09-26 09:29:54categories: 刷题 tags: 回溯的前奏：递归递归解题三部曲：1. 找整个递归的终止条件：递归应该在什么时候结束？2. 找返回值：应该给上一级返回什么信息？3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？ 回溯题1 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例一：输入: candidates = [2,3,6,7], target = 7,所求解集为:[[7],[2,2,3]] Java解法：123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int[] candidates; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; this.candidates=candidates; //sort目的是去除重复的组合如减3后再减2的情况 Arrays.sort(this.candidates); ArrayList&lt;Integer&gt; l = new ArrayList&lt;&gt;(); backtrack(this.candidates,target,l,0); return list; &#125; public void backtrack(int[] candidates, int target, ArrayList&lt;Integer&gt; l,int start)&#123; //构造的返回条件：target==0说明l中是成功组合之一，target&lt;0则说明l中组合不合格 if(target&lt;=0)&#123; //必须是clone的l,因为java传值为引用对象，l值后来的改变会影响已加入list中的l if(target==0) list.add((List&lt;Integer&gt;) l.clone()); return; &#125; for(int i=start;i&lt;candidates.length;i++)&#123; //本次递归所作的事情：将一个候选candidates[i]加入l中，并让target减去该值 l.add(candidates[i]); backtrack(candidates,target-candidates[i],l,i); //回溯，移去最后的值加入新的尝试组合 l.remove(l.size()-1); &#125; &#125;&#125;","tags":[]},{"title":"滕王阁序","date":"2021-10-30T15:03:41.000Z","path":"2021/10/30/滕王阁序/","text":"豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。 时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。 披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。 遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？ 嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ 勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？ 呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔： 滕王高阁临江渚，佩玉鸣鸾罢歌舞。 画栋朝飞南浦云，珠帘暮卷西山雨。 闲云潭影日悠悠，物换星移几度秋。 阁中帝子今何在？槛外长江空自流。","tags":[]},{"title":"linux开放端口","date":"2020-09-28T13:04:39.000Z","path":"2020/09/28/linux开放端口/","text":"Linux 防火墙新增端口失败 报错 ModuleNotFoundError: No module named ‘gi’解决方法博客链接:https://blog.csdn.net/torpidcat/article/details/105836846 开放端口博客链接：https://blog.csdn.net/realjh/article/details/82048492","tags":[]},{"title":"clion配置远程Linux终端调试C++ build乱码解决方法","date":"2020-09-27T05:47:19.000Z","path":"2020/09/27/clion配置远程Linux终端调试C-build乱码解决方法/","text":"clion中help-&gt;Edit Custom VMoptions 在最后面加入两行代码: 12-Dconsole.encoding=UTF-8 -Dfile.encoding=UTF-8","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cloudqht.github.io/tags/Linux/"}]},{"title":"ssh相关","date":"2020-09-21T14:48:24.000Z","path":"2020/09/21/ssh相关/","text":"Windows10下github生成SSH公钥 安装git，从程序目录打开 “Git Bash” ssh-keygen -t rsa -C &quot;email@email.com&quot;,email@email.com是自己github账号 提醒你输入key的名称，你可以不用输入，一路回车，就OK了； 一般会在用户目录下生成三个文件，例如我生成的文件在C:\\Users\\SmallHacker.ssh目录下 进入该用户的目录下用命令cat id_rsa.pub打开文件并复制里面的全部内容； 打开github账号–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key,并把复制好的内容全部粘贴进去 ssh免密登录12ssh-keygen -t rsassh-copy-id -i ~/.ssh/id_rsa.pub root@主机名","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cloudqht.github.io/tags/Linux/"}]},{"title":"朝游北海暮苍梧","date":"2020-07-25T07:42:01.000Z","path":"2020/07/25/博客归来/","text":"一年后更换硬盘，重新捡起以前的博客","tags":[]},{"title":"Linux下安装redis踩坑","date":"2019-10-15T01:59:48.000Z","path":"2019/10/15/Linux下安装redis踩坑/","text":"环境：virtualbox+ubuntu-18.04.3安装redis:下载：wget http://download.redis.io/releases/redis-4.0.14.tar.gz解压：tar -xzf redis-4.0.14.tar.gz创建软连接：ln -s redis-4.0.14 redis进入redis目录并编译与安装：123cd redis sudo make sudo make install 若在编译时报错提示无make命令，则需安装make：sudo apt-get install make 若出现以下错误：123456789cd src &amp;&amp; make allmake[1]: Entering directory '/home/ubuntu/redis-4.0.11/src' CC adlist.o/bin/sh: 1: cc: not foundMakefile:228: recipe for target 'adlist.o' failedmake[1]: *** [adlist.o] Error 127make[1]: Leaving directory '/home/ubuntu/redis-4.0.11/src'Makefile:6: recipe for target 'all' failedmake: *** [all] Error 2 则需安装gcc:sudo apt-get install gcc 若出现以下错误: 123456789cd src &amp;&amp; make allmake[1]: Entering directory '/home/ubuntu/redis-4.0.11/src' CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; ^~~~~~~~~~~~~~~~~~~~~compilation terminated.Makefile:228: recipe for target 'adlist.o' failed 解决方法:用make MALLOC=libc来替代make命令 若出现以下错误：12You need tcl 8.5 or newer in order to run the Redis testmake: *** [test] Error 1 则需安装tcl:1234wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz sudo tar xzvf tcl8.6.1-src.tar.gz -C /usr/local/ cd /usr/local/tcl8.6.1/unix/ sudo ./configure","tags":[]},{"title":"码云更新后需要手动更新page服务","date":"2019-09-25T13:54:01.000Z","path":"2019/09/25/码云更新后需要手动更新page服务/","text":"真他娘的憨中之憨 1重新投入github的怀抱!","tags":[]},{"title":"BCNF","date":"2019-03-21T14:30:46.000Z","path":"2019/03/21/BCNF/","text":"1.所有非主属性对每一个候选键都是完全函数依赖； 2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； 3.没有任何属性完全函数依赖于非候选键的任何一组属性。","tags":[]},{"title":"模板之拓扑排序&优先队列","date":"2019-03-12T03:49:18.000Z","path":"2019/03/12/模板题之拓扑排序-优先队列/","text":"代码模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#define maxv 1010using namespace std;vector&lt;int&gt; G[maxv];vector&lt;int&gt; res;int n,m,inDegree[maxv],num=0;bool ts()&#123; num=0; priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; q; for(int i=0;i&lt;n;i++)&#123; if(inDegree[i]==0)&#123; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.top(); res.push_back(u); q.pop(); for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; inDegree[v]--; if(inDegree[v]==0)&#123; q.push(v); &#125; &#125; // G[u].clear(); num++; &#125; if(num==n) return true; else return false;&#125;int main()&#123; for(int i=0;i&lt;maxv;i++)&#123; inDegree[i]=0; &#125; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G[a].push_back(b); inDegree[b]++; &#125; if(ts())&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; int i; for(i=0;i&lt;res.size()-1;i++)&#123; cout&lt;&lt;res[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;res[i]; &#125;else&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; cout&lt;&lt;n-num; &#125; &#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cloudqht.github.io/tags/数据结构/"}]},{"title":"求字符串最长重复串模板","date":"2019-03-05T07:07:03.000Z","path":"2019/03/05/求字符串最长重复串模板/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void radix(int * str, int *a, int *b, int n, int m)&#123; static int count[MAX]; memset(count,0,sizeof(count)); for(int i = 0; i &lt; n; ++i) ++count[str[a[i]]]; for(int i = 1; i &lt;= m; ++i) count[i] += count[i-1]; for(int i = n -1; i &gt;= 0; --i) b[--count[str[a[i]]]] = a[i];&#125; void suffix_array(int* str,int * sa, int n, int m)&#123; static int rank[MAX],a[MAX],b[MAX]; for(int i = 0; i &lt; n; ++i) rank[i] =i; radix(str,rank,sa,n,m); rank[sa[0]] = 0; for(int i = 1; i &lt; n; ++i) rank[sa[i]]= rank[sa[i-1]] +(str[sa[i]]!=str[sa[i-1]]); for(int i = 0; 1&lt;&lt;i&lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; a[j] = rank[j]+1; b[j] = j + (1&lt;&lt;i) &gt;=n? 0: rank[j + (1&lt;&lt;i)] + 1; sa[j] = j; &#125; radix(b,sa,rank,n,n); radix(a,rank,sa,n,n); rank[sa[0]] = 0; for(int j = 1; j &lt; n; ++j)&#123; rank[sa[j]] = rank[sa[j-1]] + (a[sa[j-1]] != a[sa[j]] || b[sa[j-1]] != b[sa[j]]); &#125; &#125;&#125; int duplicate_substr(string str)&#123; string rev; static int s[MAX],sa[MAX],rank[MAX],h[MAX]; int n = str.length(); copy(str.begin(),str.end(),s); suffix_array(s,sa,n,256); for(int i = 0 ; i &lt; n; ++i) rank[sa[i]] = i; int k = 0; int ans1 =0,pos1 = 0; for(int i = 0; i &lt; n; ++i)&#123; k = k==0? 0: k - 1; while(rank[i] &gt; 0 &amp;&amp; s[i + k] == s[sa[rank[i] - 1] + k]) ++k; h[rank[i]] = k; if(h[rank[i]] &gt; ans1)&#123; ans1 = h[rank[i]]; pos1 = i; &#125; &#125; return str.substr(pos1,ans1).length();&#125; 用的时候直接调用duplicate_substr()，传入字符串即可","tags":[{"name":"字符串","slug":"字符串","permalink":"https://cloudqht.github.io/tags/字符串/"}]},{"title":"git常用命令","date":"2019-02-17T04:17:38.000Z","path":"2019/02/17/git常用命令/","text":"1234567891011121314151617181920212223242526git init //初始化本地git环境git clone XXX//克隆一份代码到本地仓库git pull //把远程库的代码更新到工作台git pull --rebase origin master //强制把远程库的代码跟新到当前分支上面git fetch //把远程库的代码更新到本地库git add . //把本地的修改加到stage中git commit -m 'comments here' //把stage中的修改提交到本地库git push //把本地库的修改提交到远程库中git branch -r/-a //查看远程分支/全部分支git checkout master/branch //切换到某个分支git checkout -b test //新建test分支git checkout -d test //删除test分支git merge master //假设当前在test分支上面，把master分支上的修改同步到test分支上git merge tool //调用merge工具git stash //把未完成的修改缓存到栈容器中git stash list //查看所有的缓存git stash pop //恢复本地分支到缓存状态git blame someFile //查看某个文件的每一行的修改记录（）谁在什么时候修改的）git status //查看当前分支有哪些修改git log //查看当前分支上面的日志信息git diff //查看当前没有add的内容git diff --cache //查看已经add但是没有commit的内容git diff HEAD //上面两个内容的合并git reset --hard HEAD //撤销本地修改echo $HOME //查看git config的HOME路径export $HOME=/c/gitconfig //配置git config的HOME路径","tags":[{"name":"git常用命令","slug":"git常用命令","permalink":"https://cloudqht.github.io/tags/git常用命令/"}]},{"title":"BFS&DFS","date":"2018-10-04T15:50:28.000Z","path":"2018/10/04/BFS-DFS/","text":"BFS（Breadth-First-Search,广度优先搜索)123456789101112131415161718192021222324bool visited[MAX_VERTEX_NUM];void BFSTraverse(Graph G)&#123; for(i=0;i&lt;G.vexnum;i++)&#123; visited[i]=FALSE; &#125; InitQueue(Q); for(i=0;i&lt;G.vexnum;i++) if(!visited[i]) BFS(G,i);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v]=TRUE; Enqueue(Q,v); while(!isEmpty(Q))&#123; Dequeue(Q,v); for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,V,W))&#123; if(!isvisited(w)) visit(w); visited[w]=TRUE; Enqueue(Q,w); &#125; &#125;&#125; DFS（Depth-First-Search,深度优先搜索)12345678910111213141516bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G)&#123; for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; for(v=0;v&lt;G.vexnum;++v) if(!visited[v]) DFS(G,v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v]=TRUE; for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))&#123; if(!visited[w]) DFS(G,w); &#125;&#125;","tags":[{"name":"图","slug":"图","permalink":"https://cloudqht.github.io/tags/图/"}]},{"title":"二叉排序树及其进化（平衡二叉树）","date":"2018-09-26T15:14:33.000Z","path":"2018/09/26/二叉排序树及其进化（平衡二叉树）/","text":"二叉排序树（二叉查找树）特点：左子树值&lt;结点值&lt;右子树值，其中序遍历序列为递增有序序列 二叉排序树的插入二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。123456789101112131415int BST_Insert(BiTree &amp;T, KeyType k)&#123; if(T==NULL)&#123; T=(BiTree)malloc(sizeof(BSTNode)); T-&gt;key=k; T-&gt;lchild=NULL; T-&gt;rchild=NULL; return 1; &#125; else if(k==T-&gt;key) return 0; else if(k&lt;T-&gt;key) return BST_Insert(T-&gt;lchild, k); else return BST_Insert(T-&gt;rchild, k);&#125; 二叉排序树的建立12345678void Create_BST(BiTree &amp;T, KeyType str[], int n)&#123; //用关键字数组str[]建立一个二叉排序树 int i=0; T=NULL; while(i&lt;n)&#123; BST_Insert(T,str[i++]); &#125;&#125; 二叉排序树的非递归查找(类比线性表的二分查找)123456789101112//查找函数返回指向关键字值为key的结点指针，若不存在则返回NULLBSTNode *BST_Search(BiTree T, Elemtype key, BSTNode *&amp;p)&#123; p=NULL; //p指向被查找结点的双亲，用于插入或删除操作 while(key!=T-&gt;data&amp;&amp;T!=NULL)&#123; p=T; if(key&lt;T-&gt;data) T=T-&gt;lchild; else T=T-&gt;rchild; &#125; return T;&#125; 判断给定的二叉树是否是二叉排序树中序遍历序列为递增有序序列的二叉树即为二叉排序树。123456789101112131415KeyType predt=-65535;int JudgeBST(BiTree T)&#123; int b1,b2; if(T==NULL) return 1; else&#123; b1=JudgeBST(T-&gt;lchild); if(b1==0||T-&gt;data&lt;predt) return 0; predt=T-&gt;data; b2=JudgeBST(T-&gt;rchild); return b2; &#125;&#125; 平衡二叉树平衡二叉树是二叉排序树的演变与进化。 二叉排序树在结点插入的顺序不同时，性能可能有所不同。 举个极端例子，当用一个顺序序列建立二叉排序树时，结点的数量等于二叉树的高。此时查询一个结点的时间复杂度与单链表相同，为O(n)。这与我们想要的时间复杂度O($\\log_2 n$)相距甚远。 由于二叉排序树的性能与其高度息息相关，为避免出现性能下降的情况，则在插入结点时要充分利用其高度，避免其增长过快。由此，平衡二叉树诞生了。 平衡二叉树（AVL树）保证在插入和删除结点后，二叉树任意节点的左、右子树高度差绝对值不超过1。定义结点左右子树的高度差为结点的平衡因子。","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"完全二叉树的鉴别","date":"2018-09-26T10:38:52.000Z","path":"2018/09/26/完全二叉树的鉴别/","text":"利用完全二叉树的性质鉴别完全二叉树的1-n结点与满二叉树相同123456789101112131415161718192021bool isComplete(BiTree T)&#123; if(!T) return 1; //空二叉树为完全二叉树 InitQueue Q; BiTree p; EnQueue(Q,T); while(!IsEmpty(Q))&#123; DeQueue(Q,p); if(p)&#123; EnQueue(Q,p-&gt;lchild); EnQueue(Q,p-&gt;rchild); &#125;else&#123; while(!IsEmpty(Q))&#123; DeQueue(Q,p); if(p) return 1; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"二叉树的建立","date":"2018-09-25T15:56:19.000Z","path":"2018/09/25/二叉树的建立/","text":"由先序遍历序列和中序遍历序列确定二叉树1234567891011121314151617181920212223242526272829//A,B数组存放先序和中序结点的data//l1,l2,h1,h2分别为先序和中序的第一和最后一个结点下标BiTree PreInCreate(Elemtype A[], Elemtype B[], l1, h1, l2, h2)&#123; //建立根节点 BiTNode root = new BiTNode; //c写法为(BiTNode*)malloc(sizeof(BiTNode)); root-&gt;data=A[l1]; //找到先序遍历头结点A[l1]结点在中序遍历中的位置 for(int i=l2;B[i]!=root-&gt;data;i++); //左右子树长度 int llen=i-l2; int rlen=h2-i; //递归建立左右子树，若len=0,则左右结点置为NULL if(llen) root-&gt;lchild=PreInCreate(Elemtype A[], Elemtype B[], l1+1, l1+llen, l2, l2+llen-1); else root-&gt;lchild=NULL; if(rlen) root-&gt;rchild=PreInCreate(Elemtype A[], Elemtype B[], h1-rlen+1, h1, h2-rlen+1, h2); else root-&gt;rchild=NULL; return root; &#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"二叉树的遍历","date":"2018-09-23T13:50:18.000Z","path":"2018/09/23/二叉树的遍历/","text":"后序遍历 后序非递归遍历利用栈进行非递归遍历。算法思想：因为后序非递归遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根结点，用堆栈存储结点，必须分清返回根结点时，是从左子树返回的，还是从右子树返回的。故要使用辅助指针 r，其指向最近访问过的结点。 1234567891011121314151617181920212223void PostOrder(Bitree T)&#123; InitStack(S); p=T; r=NULL; //标志指针 while(p||!isEmpty(S))&#123; if(p)&#123; //走到最左边 push(S,p); //结点入栈 &#125;else&#123; GetTop(S,p); //取栈顶结点 if(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123; p=p-&gt;rchild; //转向右 push(S,p); p=p-&gt;lchild; //再向左 &#125;else&#123; pop(S,p); visit(p); r=p; //指向最近访问的结点 p=NULL; &#125; &#125;//else &#125;//while&#125; 通过遍历求二叉树的高 （非递归）通过队列进行层次遍历求二叉树的高12345678910111213141516171819202122//当level+1时，出队结点front结点正好是该层的最右结点， //而且此时rear结点为下层的最右结点。因为front结点右孩子就是rear结点 int Btdepth1(BiTree T)&#123; int level=0,rear=-1,front=-1; int last=0; //标志尾指针即二叉树本层的最右结点 BiTree Q[MaxSize], p; Q[++rear]=T; while(front&lt;rear)&#123; p=Q[++front]; if(p-&gt;lchild!=NULL)&#123; //若有左右子树，将左右子结点入队 Q[++rear]=p-&gt;lchild; &#125; if(p-&gt;rchild!=NULL)&#123; Q[++rear]=p-&gt;rchild; &#125; if(front==last)&#123; //出队结点正好是层次遍历该层的最右结点，则level+1 level++; last=rear; //last结点重新指向下层的最右结点 &#125; &#125;&#125; 递归方法求二叉树的高1234567891011int Btdepth2(BiTree T)&#123; if(T==NULL) return 0; int ldep=Btdepth2(T-&gt;lchild); int rdep=Btdepth2(T-&gt;rchild); if(ldep&gt;rdep) return ldep+1; else return rdep+1; &#125; 判断是否是小根堆123456789101112131415161718192021//将顺序表L[1...n]看成一个完全二叉树，扫描所有分支结点，当遇到孩子结点的关键字小于根节点关键字返回false,扫描完则返回true.bool IsMinHeap(ElemType A[], int len)&#123; //判断是否有单分支结点 if(len%2==0)&#123; //小根堆特点：双亲结点小于子结点，子结点顺序随意，此处len/2为双亲结点，len结点为子结点 if(A[len/2]&gt;A[len])&#123; return false; &#125; else&#123; for(i=len/2-1;i&gt;0;i--) if(A[i]&gt;A[i*2]||A[i]&gt;A[i*2+1]) return false; &#125; &#125; else&#123; for(i=len/2;i&gt;0;i--) if(A[i]&gt;A[i*2]||A[i]&gt;A[i*2+1]) return false; &#125; return true;&#125;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://cloudqht.github.io/tags/二叉树/"}]},{"title":"栈与队列","date":"2018-09-22T12:04:22.000Z","path":"2018/09/22/栈与队列/","text":"栈 顺序栈 定义:123456#define MaxSize 50; typedef struct&#123; int top; Elemtype data[MaxSize]; &#125;SqStack;","tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"https://cloudqht.github.io/tags/栈与队列/"}]}]