<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九华龙吟阁</title>
  
  <subtitle>都付了黄卷与青灯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cloudqht.github.io/"/>
  <updated>2020-09-21T15:04:39.321Z</updated>
  <id>https://cloudqht.github.io/</id>
  
  <author>
    <name>cloudqht</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://cloudqht.github.io/2020/09/21/ssh%E7%9B%B8%E5%85%B3/"/>
    <id>https://cloudqht.github.io/2020/09/21/ssh相关/</id>
    <published>2020-09-21T14:48:25.026Z</published>
    <updated>2020-09-21T15:04:39.321Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: ssh相关<br>date: 2020-09-21 22:48:24<br>categories: Linux</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><pre><code>&#39;&#39;&#39; ssh-keygenssh-copy-id -i ~/.ssh/id_rsa.pub root@主机名&#39;&#39;&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: ssh相关&lt;br&gt;date: 2020-09-21 22:48:24&lt;br&gt;categories: Linux&lt;/p&gt;
&lt;h2 id=&quot;tags&quot;&gt;&lt;a href=&quot;#tags&quot; class=&quot;headerlink&quot; title=&quot;tags:&quot;&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>朝游北海暮苍梧</title>
    <link href="https://cloudqht.github.io/2020/07/25/%E5%8D%9A%E5%AE%A2%E5%BD%92%E6%9D%A5/"/>
    <id>https://cloudqht.github.io/2020/07/25/博客归来/</id>
    <published>2020-07-25T07:42:01.000Z</published>
    <updated>2020-07-25T07:57:44.495Z</updated>
    
    <content type="html"><![CDATA[<p>一年后更换硬盘，重新捡起以前的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年后更换硬盘，重新捡起以前的博客&lt;/p&gt;

      
    
    </summary>
    
      <category term="日常" scheme="https://cloudqht.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下安装redis踩坑</title>
    <link href="https://cloudqht.github.io/2019/10/15/Linux%E4%B8%8B%E5%AE%89%E8%A3%85redis%E8%B8%A9%E5%9D%91/"/>
    <id>https://cloudqht.github.io/2019/10/15/Linux下安装redis踩坑/</id>
    <published>2019-10-15T01:59:48.000Z</published>
    <updated>2019-10-15T02:31:50.871Z</updated>
    
    <content type="html"><![CDATA[<p>环境：virtualbox+ubuntu-18.04.3<br>安装redis:<br>下载：<code>wget http://download.redis.io/releases/redis-4.0.14.tar.gz</code><br>解压：<code>tar -xzf redis-4.0.14.tar.gz</code><br>创建软连接：<code>ln -s redis-4.0.14 redis</code><br>进入redis目录并编译与安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> redis  </span><br><span class="line">sudo <span class="keyword">make</span>  </span><br><span class="line">sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p><p>若在编译时报错提示无make命令，则需安装make：<br><code>sudo apt-get install make</code>  </p><p>若出现以下错误：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> src &amp;&amp; <span class="keyword">make</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">    CC adlist.<span class="keyword">o</span></span><br><span class="line">/bin/<span class="keyword">sh</span>: <span class="number">1</span>: <span class="keyword">cc</span>: not found</span><br><span class="line">Makefile:<span class="number">228</span>: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: *** [adlist.<span class="keyword">o</span>] Error <span class="number">127</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">Makefile:<span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line"><span class="keyword">make</span>: *** [<span class="keyword">all</span>] Error <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>则需安装gcc:<br><code>sudo apt-get install gcc</code>  </p><p>若出现以下错误:  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[<span class="number">1</span>]: Entering directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">    CC adlist.o</span><br><span class="line">In file included from adlist<span class="selector-class">.c</span>:<span class="number">34</span>:<span class="number">0</span>:</span><br><span class="line">zmalloc<span class="selector-class">.h</span>:<span class="number">50</span>:<span class="number">10</span>: fatal error: jemalloc/jemalloc<span class="selector-class">.h</span>: No such file or directory</span><br><span class="line"> <span class="selector-id">#include</span> &lt;jemalloc/jemalloc.h&gt;</span><br><span class="line">          ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">Makefile:<span class="number">228</span>: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br></pre></td></tr></table></figure><p>解决方法:<br>用<code>make MALLOC=libc</code>来替代<code>make</code>命令  </p><p>若出现以下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You need tcl 8.5 <span class="keyword">or</span> newer <span class="keyword">in</span> order <span class="keyword">to</span> <span class="builtin-name">run</span> the Redis test</span><br><span class="line">make: *** [test] <span class="builtin-name">Error</span> 1</span><br></pre></td></tr></table></figure></p><p>则需安装tcl:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/tcl/tcl8<span class="meta">.6</span><span class="meta">.1</span>-src.tar.gz  </span><br><span class="line">sudo tar xzvf tcl8<span class="meta">.6</span><span class="meta">.1</span>-src.tar.gz  -C /usr/local/  </span><br><span class="line">cd  /usr/local/tcl8<span class="meta">.6</span><span class="meta">.1</span>/unix/  </span><br><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：virtualbox+ubuntu-18.04.3&lt;br&gt;安装redis:&lt;br&gt;下载：&lt;code&gt;wget http://download.redis.io/releases/redis-4.0.14.tar.gz&lt;/code&gt;&lt;br&gt;解压：&lt;code&gt;tar -x
      
    
    </summary>
    
      <category term="linux" scheme="https://cloudqht.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>BCNF</title>
    <link href="https://cloudqht.github.io/2019/03/21/BCNF/"/>
    <id>https://cloudqht.github.io/2019/03/21/BCNF/</id>
    <published>2019-03-21T14:30:46.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<p>1.所有非主属性对每一个候选键都是完全函数依赖； </p><p>2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； </p><p>3.没有任何属性完全函数依赖于非候选键的任何一组属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.所有非主属性对每一个候选键都是完全函数依赖； &lt;/p&gt;
&lt;p&gt;2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； &lt;/p&gt;
&lt;p&gt;3.没有任何属性完全函数依赖于非候选键的任何一组属性。&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>ff</title>
    <link href="https://cloudqht.github.io/2019/03/12/ff/"/>
    <id>https://cloudqht.github.io/2019/03/12/ff/</id>
    <published>2019-03-12T05:24:46.000Z</published>
    <updated>2020-07-25T07:03:48.042Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模板之拓扑排序&amp;优先队列</title>
    <link href="https://cloudqht.github.io/2019/03/12/%E6%A8%A1%E6%9D%BF%E9%A2%98%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://cloudqht.github.io/2019/03/12/模板题之拓扑排序-优先队列/</id>
    <published>2019-03-12T03:49:18.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<p>代码模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxv 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxv],num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ts</span><span class="params">()</span></span>&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.top();</span><br><span class="line">res.push_back(u);</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v=G[u][i];</span><br><span class="line">inDegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//G[u].clear();</span></span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxv;i++)&#123;</span><br><span class="line">inDegree[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">G[a].push_back(b);</span><br><span class="line">inDegree[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ts())&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;res.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n-num;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码模板&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="刷题" scheme="https://cloudqht.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://cloudqht.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>求字符串最长重复串模板</title>
    <link href="https://cloudqht.github.io/2019/03/05/%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E4%B8%B2%E6%A8%A1%E6%9D%BF/"/>
    <id>https://cloudqht.github.io/2019/03/05/求字符串最长重复串模板/</id>
    <published>2019-03-05T07:07:03.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void radix(<span class="built_in">int</span> * str, <span class="built_in">int</span> *a, <span class="built_in">int</span> *b, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> m)&#123;</span><br><span class="line">    static <span class="built_in">int</span> <span class="built_in">count</span>[<span class="built_in">MAX</span>];</span><br><span class="line">    memset(<span class="built_in">count</span>,<span class="number">0</span>,sizeof(<span class="built_in">count</span>));</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i) ++<span class="built_in">count</span>[str[a[i]]];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">count</span>[i] += <span class="built_in">count</span>[i-<span class="number">1</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="built_in">n</span> -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) b[--<span class="built_in">count</span>[str[a[i]]]] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void suffix_array(<span class="built_in">int</span>* str,<span class="built_in">int</span> * sa, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">int</span> <span class="built_in">rank</span>[<span class="built_in">MAX</span>],a[<span class="built_in">MAX</span>],b[<span class="built_in">MAX</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i) <span class="built_in">rank</span>[i] =i;</span><br><span class="line">    radix(str,<span class="built_in">rank</span>,sa,<span class="built_in">n</span>,m);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">rank</span>[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">n</span>; ++i)</span><br><span class="line">        <span class="built_in">rank</span>[sa[i]]= <span class="built_in">rank</span>[sa[i-<span class="number">1</span>]] +(str[sa[i]]!=str[sa[i-<span class="number">1</span>]]);</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; <span class="number">1</span>&lt;&lt;i&lt; <span class="built_in">n</span>; ++i)&#123;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">n</span>; ++j)&#123;</span><br><span class="line">            a[j] = <span class="built_in">rank</span>[j]+<span class="number">1</span>;</span><br><span class="line">            b[j] = j + (<span class="number">1</span>&lt;&lt;i) &gt;=<span class="built_in">n</span>? <span class="symbol">0:</span> <span class="built_in">rank</span>[j + (<span class="number">1</span>&lt;&lt;i)] + <span class="number">1</span>;</span><br><span class="line">            sa[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        radix(b,sa,<span class="built_in">rank</span>,<span class="built_in">n</span>,<span class="built_in">n</span>);</span><br><span class="line">        radix(a,<span class="built_in">rank</span>,sa,<span class="built_in">n</span>,<span class="built_in">n</span>);</span><br><span class="line">        <span class="built_in">rank</span>[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j)&#123;</span><br><span class="line">            <span class="built_in">rank</span>[sa[j]] = <span class="built_in">rank</span>[sa[j-<span class="number">1</span>]] + (a[sa[j-<span class="number">1</span>]] != a[sa[j]] || b[sa[j-<span class="number">1</span>]] != b[sa[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> duplicate_substr(string str)</span><br><span class="line">&#123;</span><br><span class="line">    string rev;</span><br><span class="line">    static <span class="built_in">int</span> s[<span class="built_in">MAX</span>],sa[<span class="built_in">MAX</span>],<span class="built_in">rank</span>[<span class="built_in">MAX</span>],h[<span class="built_in">MAX</span>];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = str.length();</span><br><span class="line">    copy(str.begin(),str.end(),s);</span><br><span class="line">    suffix_array(s,sa,<span class="built_in">n</span>,<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">n</span>; ++i)</span><br><span class="line">        <span class="built_in">rank</span>[sa[i]] = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> ans1 =<span class="number">0</span>,pos1 = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i)&#123;</span><br><span class="line">        k = k==<span class="number">0</span>? <span class="symbol">0:</span> k - <span class="number">1</span>;</span><br><span class="line">        while(<span class="built_in">rank</span>[i] &gt; <span class="number">0</span> &amp;&amp; s[i + k] == s[sa[<span class="built_in">rank</span>[i] - <span class="number">1</span>] + k]) ++k;</span><br><span class="line"> </span><br><span class="line">        h[<span class="built_in">rank</span>[i]] = k;</span><br><span class="line">        <span class="built_in">if</span>(h[<span class="built_in">rank</span>[i]] &gt; ans1)&#123;</span><br><span class="line">            ans1 = h[<span class="built_in">rank</span>[i]];</span><br><span class="line">            pos1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.substr(pos1,ans1).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候直接调用duplicate_substr()，传入字符串即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="机试" scheme="https://cloudqht.github.io/categories/%E6%9C%BA%E8%AF%95/"/>
    
    
      <category term="字符串" scheme="https://cloudqht.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://cloudqht.github.io/2019/02/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://cloudqht.github.io/2019/02/17/git常用命令/</id>
    <published>2019-02-17T04:17:38.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">//初始化本地git环境</span></span><br><span class="line">git clone XXX<span class="comment">//克隆一份代码到本地仓库</span></span><br><span class="line">git pull <span class="comment">//把远程库的代码更新到工作台</span></span><br><span class="line">git pull --rebase origin master <span class="comment">//强制把远程库的代码跟新到当前分支上面</span></span><br><span class="line">git fetch <span class="comment">//把远程库的代码更新到本地库</span></span><br><span class="line">git add . <span class="comment">//把本地的修改加到stage中</span></span><br><span class="line">git commit -<span class="keyword">m</span> 'comments here' <span class="comment">//把stage中的修改提交到本地库</span></span><br><span class="line">git push <span class="comment">//把本地库的修改提交到远程库中</span></span><br><span class="line">git branch -r/-a <span class="comment">//查看远程分支/全部分支</span></span><br><span class="line">git checkout master/branch <span class="comment">//切换到某个分支</span></span><br><span class="line">git checkout -b <span class="keyword">test</span> <span class="comment">//新建test分支</span></span><br><span class="line">git checkout -<span class="keyword">d</span> <span class="keyword">test</span> <span class="comment">//删除test分支</span></span><br><span class="line">git <span class="keyword">merge</span> master <span class="comment">//假设当前在test分支上面，把master分支上的修改同步到test分支上</span></span><br><span class="line">git <span class="keyword">merge</span> tool <span class="comment">//调用merge工具</span></span><br><span class="line">git stash <span class="comment">//把未完成的修改缓存到栈容器中</span></span><br><span class="line">git stash <span class="keyword">list</span> <span class="comment">//查看所有的缓存</span></span><br><span class="line">git stash pop <span class="comment">//恢复本地分支到缓存状态</span></span><br><span class="line">git blame someFile <span class="comment">//查看某个文件的每一行的修改记录（）谁在什么时候修改的）</span></span><br><span class="line">git status <span class="comment">//查看当前分支有哪些修改</span></span><br><span class="line">git <span class="keyword">log</span> <span class="comment">//查看当前分支上面的日志信息</span></span><br><span class="line">git diff <span class="comment">//查看当前没有add的内容</span></span><br><span class="line">git diff --cache <span class="comment">//查看已经add但是没有commit的内容</span></span><br><span class="line">git diff HEAD <span class="comment">//上面两个内容的合并</span></span><br><span class="line">git reset --hard HEAD <span class="comment">//撤销本地修改</span></span><br><span class="line">echo <span class="variable">$HOME</span> <span class="comment">//查看git config的HOME路径</span></span><br><span class="line">export <span class="variable">$HOME</span>=/c/gitconfig <span class="comment">//配置git config的HOME路径</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="git" scheme="https://cloudqht.github.io/categories/git/"/>
    
    
      <category term="git常用命令" scheme="https://cloudqht.github.io/tags/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>BFS&amp;DFS</title>
    <link href="https://cloudqht.github.io/2018/10/04/BFS-DFS/"/>
    <id>https://cloudqht.github.io/2018/10/04/BFS-DFS/</id>
    <published>2018-10-04T15:50:28.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS（Breadth-First-Search-广度优先搜索"><a href="#BFS（Breadth-First-Search-广度优先搜索" class="headerlink" title="BFS（Breadth-First-Search,广度优先搜索)"></a>BFS（Breadth-First-Search,广度优先搜索)</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>visited[MAX_VERTEX_NUM]<span class="comment">;</span></span><br><span class="line">void <span class="keyword">BFSTraverse(Graph </span>G)&#123;</span><br><span class="line">for(i=<span class="number">0</span><span class="comment">;i&lt;G.vexnum;i++)&#123;</span></span><br><span class="line">visited[i]=FALSE<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">InitQueue(Q)<span class="comment">;</span></span><br><span class="line">for(i=<span class="number">0</span><span class="comment">;i&lt;G.vexnum;i++)</span></span><br><span class="line">if(!visited[i])</span><br><span class="line"><span class="keyword">BFS(G,i);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">void </span><span class="keyword">BFS(Graph </span>G, int v)&#123;</span><br><span class="line">visit(v)<span class="comment">;</span></span><br><span class="line">visited[v]=TRUE<span class="comment">;</span></span><br><span class="line">Enqueue(Q,v)<span class="comment">;</span></span><br><span class="line">while(!isEmpty(Q))&#123;</span><br><span class="line">Dequeue(Q,v)<span class="comment">;</span></span><br><span class="line">for(w=FirstNeighbor(G,v)<span class="comment">;w&gt;=0;w=NextNeighbor(G,V,W))&#123;</span></span><br><span class="line">if(!isvisited(w))</span><br><span class="line">visit(w)<span class="comment">;</span></span><br><span class="line">visited[w]=TRUE<span class="comment">;</span></span><br><span class="line">Enqueue(Q,w)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS（Depth-First-Search-深度优先搜索"><a href="#DFS（Depth-First-Search-深度优先搜索" class="headerlink" title="DFS（Depth-First-Search,深度优先搜索)"></a>DFS（Depth-First-Search,深度优先搜索)</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br><span class="line">void DFSTraverse(Graph G)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">v</span>=0;v&lt;G.vexnum;++v)</span><br><span class="line">visited[v]=<span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">v</span>=0;v&lt;G.vexnum;++v)</span><br><span class="line"><span class="keyword">if</span>(!visited[v])</span><br><span class="line">DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line">void DFS(Graph G, int v)&#123;</span><br><span class="line">visit(v);</span><br><span class="line">visited[v]=<span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">w</span>=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[w])</span><br><span class="line">DFS(G,w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFS（Breadth-First-Search-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS（Breadth-First-Search-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS（Breadth-First-Search,广度优先搜
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cloudqht.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树及其进化（平衡二叉树）</title>
    <link href="https://cloudqht.github.io/2018/09/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%8A%E5%85%B6%E8%BF%9B%E5%8C%96%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/"/>
    <id>https://cloudqht.github.io/2018/09/26/二叉排序树及其进化（平衡二叉树）/</id>
    <published>2018-09-26T15:14:33.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树（二叉查找树）"><a href="#二叉排序树（二叉查找树）" class="headerlink" title="二叉排序树（二叉查找树）"></a>二叉排序树（二叉查找树）</h1><p><strong>特点：左子树值&lt;结点值&lt;右子树值，其中序遍历序列为递增有序序列</strong> </p><ul><li><h2 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h2><h3 id="二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。"><a href="#二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。" class="headerlink" title="二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。"></a><code>二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。</code></h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int BST_Insert(BiTree &amp;<span class="literal">T</span>, KeyType k)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="literal">T</span>=(BiTree)malloc(sizeof(BSTNode));</span><br><span class="line"><span class="literal">T</span>-&gt;key=k;</span><br><span class="line"><span class="literal">T</span>-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="literal">T</span>-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="literal">T</span>-&gt;key)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;<span class="literal">T</span>-&gt;key)</span><br><span class="line"><span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;lchild, k);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;rchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉排序树的建立"><a href="#二叉排序树的建立" class="headerlink" title="二叉排序树的建立"></a>二叉排序树的建立</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//用关键字数组str[]建立一个二叉排序树</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">BST_Insert(T,str[i++]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉排序树的非递归查找-类比线性表的二分查找"><a href="#二叉排序树的非递归查找-类比线性表的二分查找" class="headerlink" title="二叉排序树的非递归查找(类比线性表的二分查找)"></a>二叉排序树的非递归查找(类比线性表的二分查找)</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//查找函数返回指向关键字值为key的结点指针，若不存在则返回<span class="literal">NULL</span></span><br><span class="line">BSTNode *BST_Search(BiTree <span class="literal">T</span>, Elemtype key, BSTNode *&amp;p)&#123; </span><br><span class="line">p=<span class="literal">NULL</span>;//p指向被查找结点的双亲，用于插入或删除操作</span><br><span class="line"><span class="keyword">while</span>(key!=<span class="literal">T</span>-&gt;data&amp;&amp;<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p=<span class="literal">T</span>;</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="literal">T</span>-&gt;data)</span><br><span class="line"><span class="literal">T</span>=<span class="literal">T</span>-&gt;lchild;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="literal">T</span>=<span class="literal">T</span>-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">T</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="判断给定的二叉树是否是二叉排序树"><a href="#判断给定的二叉树是否是二叉排序树" class="headerlink" title="判断给定的二叉树是否是二叉排序树"></a>判断给定的二叉树是否是二叉排序树</h2><h3 id="中序遍历序列为递增有序序列的二叉树即为二叉排序树。"><a href="#中序遍历序列为递增有序序列的二叉树即为二叉排序树。" class="headerlink" title="中序遍历序列为递增有序序列的二叉树即为二叉排序树。"></a><code>中序遍历序列为递增有序序列的二叉树即为二叉排序树。</code></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KeyType <span class="attribute">predt</span>=-65535;</span><br><span class="line"></span><br><span class="line">int JudgeBST(BiTree T)&#123;</span><br><span class="line">int b1,b2;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">T</span>==NULL)</span><br><span class="line">return 1;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="attribute">b1</span>=JudgeBST(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">b1</span>==0||T-&gt;data&lt;predt)</span><br><span class="line">return 0;</span><br><span class="line"><span class="attribute">predt</span>=T-&gt;data;</span><br><span class="line"><span class="attribute">b2</span>=JudgeBST(T-&gt;rchild);</span><br><span class="line">return b2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树是二叉排序树的演变与进化。 </p><p>二叉排序树在结点插入的顺序不同时，性能可能有所不同。 </p><p>举个极端例子，当用一个顺序序列建立二叉排序树时，结点的数量等于二叉树的高。此时查询一个结点的时间复杂度与单链表相同，为O(n)。这与我们想要的时间复杂度O($\log_2 n$)相距甚远。 </p><p>由于二叉排序树的性能与其高度息息相关，为避免出现性能下降的情况，则在插入结点时要充分利用其高度，避免其增长过快。由此，平衡二叉树诞生了。 </p><p>平衡二叉树（AVL树）保证在插入和删除结点后，二叉树任意节点的左、右子树高度差绝对值不超过1。定义结点左右子树的高度差为结点的平衡因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉排序树（二叉查找树）&quot;&gt;&lt;a href=&quot;#二叉排序树（二叉查找树）&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树（二叉查找树）&quot;&gt;&lt;/a&gt;二叉排序树（二叉查找树）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;特点：左子树值&amp;lt;结点值&amp;lt;右子树值
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的鉴别</title>
    <link href="https://cloudqht.github.io/2018/09/26/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%89%B4%E5%88%AB/"/>
    <id>https://cloudqht.github.io/2018/09/26/完全二叉树的鉴别/</id>
    <published>2018-09-26T10:38:52.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用完全二叉树的性质鉴别"><a href="#利用完全二叉树的性质鉴别" class="headerlink" title="利用完全二叉树的性质鉴别"></a>利用完全二叉树的性质鉴别</h2><h3 id="完全二叉树的1-n结点与满二叉树相同"><a href="#完全二叉树的1-n结点与满二叉树相同" class="headerlink" title="完全二叉树的1-n结点与满二叉树相同"></a><code>完全二叉树的1-n结点与满二叉树相同</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool isComplete(BiTree T)&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//空二叉树为完全二叉树</span></span><br><span class="line">InitQueue Q;</span><br><span class="line">BiTree p;</span><br><span class="line">EnQueue(Q,T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">DeQueue(Q,p);</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">EnQueue(Q,p-&gt;lchild);</span><br><span class="line">EnQueue(Q,p-&gt;rchild);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">DeQueue(Q,p);</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用完全二叉树的性质鉴别&quot;&gt;&lt;a href=&quot;#利用完全二叉树的性质鉴别&quot; class=&quot;headerlink&quot; title=&quot;利用完全二叉树的性质鉴别&quot;&gt;&lt;/a&gt;利用完全二叉树的性质鉴别&lt;/h2&gt;&lt;h3 id=&quot;完全二叉树的1-n结点与满二叉树相同&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的建立</title>
    <link href="https://cloudqht.github.io/2018/09/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://cloudqht.github.io/2018/09/25/二叉树的建立/</id>
    <published>2018-09-25T15:56:19.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由先序遍历序列和中序遍历序列确定二叉树"><a href="#由先序遍历序列和中序遍历序列确定二叉树" class="headerlink" title="由先序遍历序列和中序遍历序列确定二叉树"></a>由先序遍历序列和中序遍历序列确定二叉树</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A,B数组存放先序和中序结点的data</span></span><br><span class="line"><span class="comment">//l1,l2,h1,h2分别为先序和中序的第一和最后一个结点下标</span></span><br><span class="line">BiTree PreInCreate(Elemtype A[], Elemtype B[], l1, h1, l2, h2)&#123; </span><br><span class="line"><span class="comment">//建立根节点</span></span><br><span class="line">BiTNode root = new BiTNode;<span class="comment">//c写法为(BiTNode*)malloc(sizeof(BiTNode));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span><span class="keyword">data</span>=A[l1];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到先序遍历头结点A[l1]结点在中序遍历中的位置</span></span><br><span class="line"><span class="function"><span class="title">for</span>(int i=l2;B[i]!=root-&gt;</span><span class="keyword">data</span>;i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右子树长度</span></span><br><span class="line">int llen=i-l2;</span><br><span class="line">int rlen=h2-i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归建立左右子树，若len=0,则左右结点置为NULL</span></span><br><span class="line"><span class="keyword">if</span>(llen)</span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>lchild=PreInCreate(Elemtype A[], Elemtype B[],</span><br><span class="line"> l1+<span class="number">1</span>, l1+llen, l2, l2+llen-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>lchild=NULL;</span><br><span class="line"><span class="keyword">if</span>(rlen)</span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>rchild=PreInCreate(Elemtype A[], Elemtype B[],</span><br><span class="line"> h1-rlen+<span class="number">1</span>, h1, h2-rlen+<span class="number">1</span>, h2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>rchild=NULL;</span><br><span class="line"></span><br><span class="line">return root; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;由先序遍历序列和中序遍历序列确定二叉树&quot;&gt;&lt;a href=&quot;#由先序遍历序列和中序遍历序列确定二叉树&quot; class=&quot;headerlink&quot; title=&quot;由先序遍历序列和中序遍历序列确定二叉树&quot;&gt;&lt;/a&gt;由先序遍历序列和中序遍历序列确定二叉树&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="https://cloudqht.github.io/2018/09/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://cloudqht.github.io/2018/09/23/二叉树的遍历/</id>
    <published>2018-09-23T13:50:18.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><ul><li><h2 id="后序非递归遍历"><a href="#后序非递归遍历" class="headerlink" title="后序非递归遍历"></a>后序非递归遍历</h2><code>利用栈进行非递归遍历。</code><br>算法思想：因为后序非递归遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根结点，用堆栈存储结点，必须分清返回根结点时，是从左子树返回的，还是从右子树返回的。故要使用辅助指针 r，其指向最近访问过的结点。 <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void PostOrder(Bitree T)&#123; </span><br><span class="line">InitStack(S); </span><br><span class="line">p=T; </span><br><span class="line">r=NULL;<span class="comment">//标志指针 </span></span><br><span class="line"><span class="keyword">while</span>(p||!isEmpty(S))&#123; </span><br><span class="line"><span class="keyword">if</span>(p)&#123;<span class="comment">//走到最左边 </span></span><br><span class="line">push(S,p);<span class="comment">//结点入栈</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">GetTop(S,p);<span class="comment">//取栈顶结点</span></span><br><span class="line"><span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">rchild</span>&amp;&amp;p-&gt;</span>rchild!=r)&#123;</span><br><span class="line"><span class="function"><span class="title">p</span>=p-&gt;</span>rchild;<span class="comment">//转向右</span></span><br><span class="line">push(S,p);</span><br><span class="line"><span class="function"><span class="title">p</span>=p-&gt;</span>lchild;<span class="comment">//再向左</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pop(S,p);</span><br><span class="line">visit(p);</span><br><span class="line">r=p;<span class="comment">//指向最近访问的结点</span></span><br><span class="line">p=NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//else</span></span><br><span class="line">&#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="通过遍历求二叉树的高"><a href="#通过遍历求二叉树的高" class="headerlink" title="通过遍历求二叉树的高"></a>通过遍历求二叉树的高</h1><ul><li><h2 id="（非递归）通过队列进行层次遍历求二叉树的高"><a href="#（非递归）通过队列进行层次遍历求二叉树的高" class="headerlink" title="（非递归）通过队列进行层次遍历求二叉树的高"></a>（非递归）通过队列进行层次遍历求二叉树的高</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当level+1时，出队结点front结点正好是该层的最右结点， </span></span><br><span class="line"><span class="comment">//而且此时rear结点为下层的最右结点。因为front结点右孩子就是rear结点 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Btdepth1(BiTree T)&#123;</span><br><span class="line"><span class="keyword">int</span> level=<span class="number">0</span>,rear=<span class="number">-1</span>,front=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> last=<span class="number">0</span>;<span class="comment">//标志尾指针即二叉树本层的最右结点</span></span><br><span class="line">BiTree Q[MaxSize], p;</span><br><span class="line">Q[++rear]=T;</span><br><span class="line"><span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">p=Q[++front];</span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild!=<span class="keyword">NULL</span>)&#123;<span class="comment">//若有左右子树，将左右子结点入队</span></span><br><span class="line">Q[++rear]=p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild!=<span class="keyword">NULL</span>)&#123;</span><br><span class="line">Q[++rear]=p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(front==last)&#123;<span class="comment">//出队结点正好是层次遍历该层的最右结点，则level+1</span></span><br><span class="line">level++;</span><br><span class="line">last=rear;<span class="comment">//last结点重新指向下层的最右结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="递归方法求二叉树的高"><a href="#递归方法求二叉树的高" class="headerlink" title="递归方法求二叉树的高"></a>递归方法求二叉树的高</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Btdepth2(BiTree T)&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ldep=Btdepth2(T-&gt;lchild);</span><br><span class="line"><span class="keyword">int</span> rdep=Btdepth2(T-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span>(ldep&gt;rdep)</span><br><span class="line"><span class="keyword">return</span> ldep+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> rdep+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="判断是否是小根堆"><a href="#判断是否是小根堆" class="headerlink" title="判断是否是小根堆"></a>判断是否是小根堆</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//将顺序表L[<span class="number">1.</span>..n]看成一个完全二叉树，扫描所有分支结点，当遇到孩子结点的关键字小于根节点关键字返回<span class="literal">false</span>,扫描完则返回<span class="literal">true</span>.</span><br><span class="line">bool IsMinHeap(ElemType A[], int <span class="built_in">len</span>)&#123;</span><br><span class="line">//判断是否有单分支结点</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">//小根堆特点：双亲结点小于子结点，子结点顺序随意，此处<span class="built_in">len</span>/<span class="number">2</span>为双亲结点，<span class="built_in">len</span>结点为子结点</span><br><span class="line"><span class="keyword">if</span>(A[<span class="built_in">len</span>/<span class="number">2</span>]&gt;A[<span class="built_in">len</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>;i&gt;<span class="number">0</span>;i<span class="comment">--)</span></span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;A[i*<span class="number">2</span>]||A[i]&gt;A[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="built_in">len</span>/<span class="number">2</span>;i&gt;<span class="number">0</span>;i<span class="comment">--)</span></span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;A[i*<span class="number">2</span>]||A[i]&gt;A[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后序遍历&quot;&gt;&lt;a href=&quot;#后序遍历&quot; class=&quot;headerlink&quot; title=&quot;后序遍历&quot;&gt;&lt;/a&gt;后序遍历&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;后序非递归遍历&quot;&gt;&lt;a href=&quot;#后序非递归遍历&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://cloudqht.github.io/2018/09/22/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://cloudqht.github.io/2018/09/22/栈与队列/</id>
    <published>2018-09-22T12:04:22.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2></li></ul><p><code>定义:</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line"><span class="keyword">int</span> top; </span><br><span class="line">Elemtype data[MaxSize]; </span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈与队列" scheme="https://cloudqht.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
