<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九华龙吟阁</title>
  
  <subtitle>都付了黄卷与青灯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cloudqht.github.io/"/>
  <updated>2022-04-05T13:25:18.188Z</updated>
  <id>https://cloudqht.github.io/</id>
  
  <author>
    <name>cloudqht</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊天演进</title>
    <link href="https://cloudqht.github.io/2022/04/05/%E8%81%8A%E5%A4%A9%E6%BC%94%E8%BF%9B/"/>
    <id>https://cloudqht.github.io/2022/04/05/聊天演进/</id>
    <published>2022-04-05T13:20:12.000Z</published>
    <updated>2022-04-05T13:25:18.188Z</updated>
    
    <content type="html"><![CDATA[<p>我可能是一个没有多少内涵的人<br>聊多了乏味无话可说<br>各个领域谈完了不想重复<br>如何解决<br>应该是解决不了<br>解决不了就被动一点吧<br>可能停一阵子<br>更有助于放弃不切实际的幻想<br>回到以前的生活方式吧，无缘注定无缘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我可能是一个没有多少内涵的人&lt;br&gt;聊多了乏味无话可说&lt;br&gt;各个领域谈完了不想重复&lt;br&gt;如何解决&lt;br&gt;应该是解决不了&lt;br&gt;解决不了就被动一点吧&lt;br&gt;可能停一阵子&lt;br&gt;更有助于放弃不切实际的幻想&lt;br&gt;回到以前的生活方式吧，无缘注定无缘&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="心路历程" scheme="https://cloudqht.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>放弃不切实际的幻想</title>
    <link href="https://cloudqht.github.io/2022/04/05/%E6%94%BE%E5%BC%83%E4%B8%8D%E5%88%87%E5%AE%9E%E9%99%85%E7%9A%84%E5%B9%BB%E6%83%B3/"/>
    <id>https://cloudqht.github.io/2022/04/05/放弃不切实际的幻想/</id>
    <published>2022-04-05T02:30:55.000Z</published>
    <updated>2022-04-05T02:33:59.429Z</updated>
    
    <content type="html"><![CDATA[<p>只是特殊时期的特殊情况罢了<br>不要多想<br>换一个人会有不同吗，大概率是没有<br>享受当下<br>珍惜这样的体验<br>放弃不切实际的幻想</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只是特殊时期的特殊情况罢了&lt;br&gt;不要多想&lt;br&gt;换一个人会有不同吗，大概率是没有&lt;br&gt;享受当下&lt;br&gt;珍惜这样的体验&lt;br&gt;放弃不切实际的幻想&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="心路历程" scheme="https://cloudqht.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xszk-初级阶段</title>
    <link href="https://cloudqht.github.io/2022/03/27/xszk-%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5/"/>
    <id>https://cloudqht.github.io/2022/03/27/xszk-初级阶段/</id>
    <published>2022-03-27T11:57:35.000Z</published>
    <updated>2022-03-27T12:13:09.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谢谢你让我爱过你-S-H-E"><a href="#谢谢你让我爱过你-S-H-E" class="headerlink" title="谢谢你让我爱过你-S.H.E"></a>谢谢你让我爱过你-S.H.E</h3><p>感觉天气冷了就加件毛衣</p><p>而不是急着躲进某个人的怀里</p><p>这种简单的快乐我竟然忘记</p><p>直到你离去才恢复记忆</p><p>还可以呼吸心跳也还规律</p><p>只除了寂寞它还不肯马上就平息</p><p>相恋和失恋如果说都需要练习</p><p>一次学会两种也算好事情</p><p>谢谢你教会我爱需要两颗心</p><p>谢谢你示范了什么人该放弃</p><p>谢谢你提醒我痛会唤醒勇气</p><p>谢谢你曾让我这样的爱过你</p><p>只要睁开眼睛就有好风景</p><p>再不用苦苦等你偶尔的好心情</p><p>这种简单的快乐比玫瑰美丽</p><p>我相信伤心会慢慢痊愈</p><p>还可以呼吸心跳也还规律</p><p>只除了寂寞它还不肯马上就平息</p><p>相恋和失恋如果说都需要练习</p><p>一次学会两种也算好事情</p><p>谢谢你教会我爱需要两颗心</p><p>谢谢你示范了什么人该放弃</p><p>谢谢你提醒我痛会唤醒勇气</p><p>谢谢你曾让我这样的爱过你</p><p>谢谢你教会我爱需要两颗心</p><p>谢谢你示范了什么人该放弃</p><p>谢谢你提醒我痛会唤醒勇气</p><p>谢谢你曾让我这样的爱过你</p><h3 id="xszk"><a href="#xszk" class="headerlink" title="xszk"></a>xszk</h3><p>这种奇妙的感觉…念头不时在大脑里出现，今日记录一下。<br>非常奇妙的体验，但应该是没有可能了…这就是人生吧，感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谢谢你让我爱过你-S-H-E&quot;&gt;&lt;a href=&quot;#谢谢你让我爱过你-S-H-E&quot; class=&quot;headerlink&quot; title=&quot;谢谢你让我爱过你-S.H.E&quot;&gt;&lt;/a&gt;谢谢你让我爱过你-S.H.E&lt;/h3&gt;&lt;p&gt;感觉天气冷了就加件毛衣&lt;/p&gt;
&lt;p&gt;而不是
      
    
    </summary>
    
    
      <category term="心路历程" scheme="https://cloudqht.github.io/tags/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>gitee ssh key algorithm problem</title>
    <link href="https://cloudqht.github.io/2021/10/31/gitee-ssh-key-algorithm-problem/"/>
    <id>https://cloudqht.github.io/2021/10/31/gitee-ssh-key-algorithm-problem/</id>
    <published>2021-10-30T16:45:05.000Z</published>
    <updated>2021-10-30T16:45:51.326Z</updated>
    
    <content type="html"><![CDATA[<p>更换秘钥生成算法，使用 ed25519 算法生成<br>ssh-keygen -t ed25519 -C “your email”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更换秘钥生成算法，使用 ed25519 算法生成&lt;br&gt;ssh-keygen -t ed25519 -C “your email”&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cloudqht.github.io/2021/10/31/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://cloudqht.github.io/2021/10/31/回溯算法/</id>
    <published>2021-10-30T16:40:37.053Z</published>
    <updated>2021-10-30T16:40:37.053Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 回溯算法<br>date: 2019-09-26 09:29:54<br>categories: 刷题</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><ul><li><h3 id="回溯的前奏：递归"><a href="#回溯的前奏：递归" class="headerlink" title="回溯的前奏：递归"></a>回溯的前奏：递归</h3><h4 id="递归解题三部曲："><a href="#递归解题三部曲：" class="headerlink" title="递归解题三部曲："></a>递归解题三部曲：</h4><h4 id="1-找整个递归的终止条件：递归应该在什么时候结束？"><a href="#1-找整个递归的终止条件：递归应该在什么时候结束？" class="headerlink" title="1. 找整个递归的终止条件：递归应该在什么时候结束？"></a>1. 找整个递归的终止条件：递归应该在什么时候结束？</h4><h4 id="2-找返回值：应该给上一级返回什么信息？"><a href="#2-找返回值：应该给上一级返回什么信息？" class="headerlink" title="2. 找返回值：应该给上一级返回什么信息？"></a>2. 找返回值：应该给上一级返回什么信息？</h4><h4 id="3-本级递归应该做什么：在这一级递归中，应该完成什么任务？"><a href="#3-本级递归应该做什么：在这一级递归中，应该完成什么任务？" class="headerlink" title="3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？"></a>3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？</h4></li><li><h3 id="回溯题1"><a href="#回溯题1" class="headerlink" title="回溯题1"></a>回溯题1</h3><blockquote><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 </p><p>candidates 中的数字可以无限制重复被选取。 </p><p><strong>说明：</strong></p><ul><li><strong>所有数字（包括 target）都是正整数。</strong></li><li><strong>解集不能包含重复的组合。</strong>  </li></ul><p><strong>示例一：</strong><br><strong>输入:</strong> candidates = [2,3,6,7], target = 7,<br><strong>所求解集为:</strong><br>[<br>[7],<br>[2,2,3]<br>]  </p></blockquote></li></ul><p><strong>Java解法：</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] candidates;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.candidates=candidates;</span><br><span class="line">        <span class="comment">//sort目的是去除重复的组合如减3后再减2的情况</span></span><br><span class="line">        Arrays.sort(<span class="keyword">this</span>.candidates);</span><br><span class="line">        ArrayList&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(<span class="keyword">this</span>.candidates,<span class="keyword">target</span>,l,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, ArrayList&lt;Integer&gt; l,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造的返回条件：target==0说明l中是成功组合之一，target&lt;0则说明l中组合不合格</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//必须是clone的l,因为java传值为引用对象，l值后来的改变会影响已加入list中的l</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">target</span>==<span class="number">0</span>) list.add((List&lt;Integer&gt;) l.clone());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="comment">//本次递归所作的事情：将一个候选candidates[i]加入l中，并让target减去该值</span></span><br><span class="line">            l.add(candidates[i]);</span><br><span class="line">            backtrack(candidates,<span class="keyword">target</span>-candidates[i],l,i);</span><br><span class="line">            <span class="comment">//回溯，移去最后的值加入新的尝试组合</span></span><br><span class="line">            l.remove(l.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 回溯算法&lt;br&gt;date: 2019-09-26 09:29:54&lt;br&gt;categories: 刷题&lt;/p&gt;
&lt;h2 id=&quot;tags&quot;&gt;&lt;a href=&quot;#tags&quot; class=&quot;headerlink&quot; title=&quot;tags:&quot;&gt;&lt;/a&gt;ta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滕王阁序</title>
    <link href="https://cloudqht.github.io/2021/10/30/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/"/>
    <id>https://cloudqht.github.io/2021/10/30/滕王阁序/</id>
    <published>2021-10-30T15:03:41.000Z</published>
    <updated>2021-10-30T15:05:41.221Z</updated>
    
    <content type="html"><![CDATA[<p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p><p>画栋朝飞南浦云，珠帘暮卷西山雨。</p><p>闲云潭影日悠悠，物换星移几度秋。</p><p>阁中帝子今何在？槛外长江空自流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux开放端口</title>
    <link href="https://cloudqht.github.io/2020/09/28/linux%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/"/>
    <id>https://cloudqht.github.io/2020/09/28/linux开放端口/</id>
    <published>2020-09-28T13:04:39.000Z</published>
    <updated>2020-09-28T13:06:26.747Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 防火墙新增端口失败 报错 ModuleNotFoundError: No module named ‘gi’<br>解决方法博客链接:<a href="https://blog.csdn.net/torpidcat/article/details/105836846" target="_blank" rel="noopener">https://blog.csdn.net/torpidcat/article/details/105836846</a> </p><p>开放端口博客链接：<a href="https://blog.csdn.net/realjh/article/details/82048492" target="_blank" rel="noopener">https://blog.csdn.net/realjh/article/details/82048492</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 防火墙新增端口失败 报错 ModuleNotFoundError: No module named ‘gi’&lt;br&gt;解决方法博客链接:&lt;a href=&quot;https://blog.csdn.net/torpidcat/article/details/1058368
      
    
    </summary>
    
      <category term="Linux" scheme="https://cloudqht.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>clion配置远程Linux终端调试C++ build乱码解决方法</title>
    <link href="https://cloudqht.github.io/2020/09/27/clion%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8BLinux%E7%BB%88%E7%AB%AF%E8%B0%83%E8%AF%95C-build%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://cloudqht.github.io/2020/09/27/clion配置远程Linux终端调试C-build乱码解决方法/</id>
    <published>2020-09-27T05:47:19.000Z</published>
    <updated>2020-09-27T05:57:50.334Z</updated>
    
    <content type="html"><![CDATA[<ol><li>clion中help-&gt;Edit Custom VMoptions </li><li>在最后面加入两行代码: <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Dconsole.<span class="attribute">encoding</span>=UTF-8 </span><br><span class="line">-Dfile.<span class="attribute">encoding</span>=UTF-8</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;clion中help-&amp;gt;Edit Custom VMoptions &lt;/li&gt;
&lt;li&gt;在最后面加入两行代码: &lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Linux" scheme="https://cloudqht.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cloudqht.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ssh相关</title>
    <link href="https://cloudqht.github.io/2020/09/21/ssh%E7%9B%B8%E5%85%B3/"/>
    <id>https://cloudqht.github.io/2020/09/21/ssh相关/</id>
    <published>2020-09-21T14:48:24.000Z</published>
    <updated>2020-09-21T15:22:55.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows10下github生成SSH公钥"><a href="#Windows10下github生成SSH公钥" class="headerlink" title="Windows10下github生成SSH公钥"></a>Windows10下github生成SSH公钥</h3><ol><li>安装git，从程序目录打开 “Git Bash” </li><li><code>ssh-keygen -t rsa -C &quot;email@email.com&quot;</code>,email@email.com是自己github账号 </li><li>提醒你输入key的名称，你可以不用输入，一路回车，就OK了；</li><li>一般会在用户目录下生成三个文件，例如我生成的文件在C:\Users\SmallHacker.ssh目录下 </li><li>进入该用户的目录下用命令cat id_rsa.pub打开文件并复制里面的全部内容； </li><li>打开github账号–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key,并把复制好的内容全部粘贴进去 </li></ol><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id -<span class="selector-tag">i</span> ~/.ssh/id_rsa<span class="selector-class">.pub</span> root@主机名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Windows10下github生成SSH公钥&quot;&gt;&lt;a href=&quot;#Windows10下github生成SSH公钥&quot; class=&quot;headerlink&quot; title=&quot;Windows10下github生成SSH公钥&quot;&gt;&lt;/a&gt;Windows10下github生
      
    
    </summary>
    
      <category term="Linux" scheme="https://cloudqht.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cloudqht.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>朝游北海暮苍梧</title>
    <link href="https://cloudqht.github.io/2020/07/25/%E5%8D%9A%E5%AE%A2%E5%BD%92%E6%9D%A5/"/>
    <id>https://cloudqht.github.io/2020/07/25/博客归来/</id>
    <published>2020-07-25T07:42:01.000Z</published>
    <updated>2020-07-25T07:57:44.495Z</updated>
    
    <content type="html"><![CDATA[<p>一年后更换硬盘，重新捡起以前的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年后更换硬盘，重新捡起以前的博客&lt;/p&gt;

      
    
    </summary>
    
      <category term="日常" scheme="https://cloudqht.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下安装redis踩坑</title>
    <link href="https://cloudqht.github.io/2019/10/15/Linux%E4%B8%8B%E5%AE%89%E8%A3%85redis%E8%B8%A9%E5%9D%91/"/>
    <id>https://cloudqht.github.io/2019/10/15/Linux下安装redis踩坑/</id>
    <published>2019-10-15T01:59:48.000Z</published>
    <updated>2019-10-15T02:31:50.871Z</updated>
    
    <content type="html"><![CDATA[<p>环境：virtualbox+ubuntu-18.04.3<br>安装redis:<br>下载：<code>wget http://download.redis.io/releases/redis-4.0.14.tar.gz</code><br>解压：<code>tar -xzf redis-4.0.14.tar.gz</code><br>创建软连接：<code>ln -s redis-4.0.14 redis</code><br>进入redis目录并编译与安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> redis  </span><br><span class="line">sudo <span class="keyword">make</span>  </span><br><span class="line">sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p><p>若在编译时报错提示无make命令，则需安装make：<br><code>sudo apt-get install make</code>  </p><p>若出现以下错误：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> src &amp;&amp; <span class="keyword">make</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Entering directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">    CC adlist.<span class="keyword">o</span></span><br><span class="line">/bin/<span class="keyword">sh</span>: <span class="number">1</span>: <span class="keyword">cc</span>: not found</span><br><span class="line">Makefile:<span class="number">228</span>: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: *** [adlist.<span class="keyword">o</span>] Error <span class="number">127</span></span><br><span class="line"><span class="keyword">make</span>[<span class="number">1</span>]: Leaving directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">Makefile:<span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line"><span class="keyword">make</span>: *** [<span class="keyword">all</span>] Error <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>则需安装gcc:<br><code>sudo apt-get install gcc</code>  </p><p>若出现以下错误:  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd src &amp;&amp; make all</span><br><span class="line">make[<span class="number">1</span>]: Entering directory <span class="string">'/home/ubuntu/redis-4.0.11/src'</span></span><br><span class="line">    CC adlist.o</span><br><span class="line">In file included from adlist<span class="selector-class">.c</span>:<span class="number">34</span>:<span class="number">0</span>:</span><br><span class="line">zmalloc<span class="selector-class">.h</span>:<span class="number">50</span>:<span class="number">10</span>: fatal error: jemalloc/jemalloc<span class="selector-class">.h</span>: No such file or directory</span><br><span class="line"> <span class="selector-id">#include</span> &lt;jemalloc/jemalloc.h&gt;</span><br><span class="line">          ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">Makefile:<span class="number">228</span>: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br></pre></td></tr></table></figure><p>解决方法:<br>用<code>make MALLOC=libc</code>来替代<code>make</code>命令  </p><p>若出现以下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You need tcl 8.5 <span class="keyword">or</span> newer <span class="keyword">in</span> order <span class="keyword">to</span> <span class="builtin-name">run</span> the Redis test</span><br><span class="line">make: *** [test] <span class="builtin-name">Error</span> 1</span><br></pre></td></tr></table></figure></p><p>则需安装tcl:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/tcl/tcl8<span class="meta">.6</span><span class="meta">.1</span>-src.tar.gz  </span><br><span class="line">sudo tar xzvf tcl8<span class="meta">.6</span><span class="meta">.1</span>-src.tar.gz  -C /usr/local/  </span><br><span class="line">cd  /usr/local/tcl8<span class="meta">.6</span><span class="meta">.1</span>/unix/  </span><br><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：virtualbox+ubuntu-18.04.3&lt;br&gt;安装redis:&lt;br&gt;下载：&lt;code&gt;wget http://download.redis.io/releases/redis-4.0.14.tar.gz&lt;/code&gt;&lt;br&gt;解压：&lt;code&gt;tar -x
      
    
    </summary>
    
      <category term="linux" scheme="https://cloudqht.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>码云更新后需要手动更新page服务</title>
    <link href="https://cloudqht.github.io/2019/09/25/%E7%A0%81%E4%BA%91%E6%9B%B4%E6%96%B0%E5%90%8E%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0page%E6%9C%8D%E5%8A%A1/"/>
    <id>https://cloudqht.github.io/2019/09/25/码云更新后需要手动更新page服务/</id>
    <published>2019-09-25T13:54:01.000Z</published>
    <updated>2021-10-30T16:40:37.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="真他娘的憨中之憨"><a href="#真他娘的憨中之憨" class="headerlink" title="真他娘的憨中之憨"></a>真他娘的憨中之憨</h1><hr><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新投入github的怀抱!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;真他娘的憨中之憨&quot;&gt;&lt;a href=&quot;#真他娘的憨中之憨&quot; class=&quot;headerlink&quot; title=&quot;真他娘的憨中之憨&quot;&gt;&lt;/a&gt;真他娘的憨中之憨&lt;/h1&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight erlang-repl&quot;&gt;&lt;table
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BCNF</title>
    <link href="https://cloudqht.github.io/2019/03/21/BCNF/"/>
    <id>https://cloudqht.github.io/2019/03/21/BCNF/</id>
    <published>2019-03-21T14:30:46.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<p>1.所有非主属性对每一个候选键都是完全函数依赖； </p><p>2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； </p><p>3.没有任何属性完全函数依赖于非候选键的任何一组属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.所有非主属性对每一个候选键都是完全函数依赖； &lt;/p&gt;
&lt;p&gt;2.所有的主属性对每一个不包含它的候选键，也是完全函数依赖； &lt;/p&gt;
&lt;p&gt;3.没有任何属性完全函数依赖于非候选键的任何一组属性。&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>模板之拓扑排序&amp;优先队列</title>
    <link href="https://cloudqht.github.io/2019/03/12/%E6%A8%A1%E6%9D%BF%E9%A2%98%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://cloudqht.github.io/2019/03/12/模板题之拓扑排序-优先队列/</id>
    <published>2019-03-12T03:49:18.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<p>代码模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxv 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxv],num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ts</span><span class="params">()</span></span>&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.top();</span><br><span class="line">res.push_back(u);</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v=G[u][i];</span><br><span class="line">inDegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//G[u].clear();</span></span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxv;i++)&#123;</span><br><span class="line">inDegree[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">G[a].push_back(b);</span><br><span class="line">inDegree[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ts())&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;res.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res[i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n-num;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码模板&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="刷题" scheme="https://cloudqht.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://cloudqht.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>求字符串最长重复串模板</title>
    <link href="https://cloudqht.github.io/2019/03/05/%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E4%B8%B2%E6%A8%A1%E6%9D%BF/"/>
    <id>https://cloudqht.github.io/2019/03/05/求字符串最长重复串模板/</id>
    <published>2019-03-05T07:07:03.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void radix(<span class="built_in">int</span> * str, <span class="built_in">int</span> *a, <span class="built_in">int</span> *b, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> m)&#123;</span><br><span class="line">    static <span class="built_in">int</span> <span class="built_in">count</span>[<span class="built_in">MAX</span>];</span><br><span class="line">    memset(<span class="built_in">count</span>,<span class="number">0</span>,sizeof(<span class="built_in">count</span>));</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i) ++<span class="built_in">count</span>[str[a[i]]];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">count</span>[i] += <span class="built_in">count</span>[i-<span class="number">1</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="built_in">n</span> -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) b[--<span class="built_in">count</span>[str[a[i]]]] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void suffix_array(<span class="built_in">int</span>* str,<span class="built_in">int</span> * sa, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">int</span> <span class="built_in">rank</span>[<span class="built_in">MAX</span>],a[<span class="built_in">MAX</span>],b[<span class="built_in">MAX</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i) <span class="built_in">rank</span>[i] =i;</span><br><span class="line">    radix(str,<span class="built_in">rank</span>,sa,<span class="built_in">n</span>,m);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">rank</span>[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">n</span>; ++i)</span><br><span class="line">        <span class="built_in">rank</span>[sa[i]]= <span class="built_in">rank</span>[sa[i-<span class="number">1</span>]] +(str[sa[i]]!=str[sa[i-<span class="number">1</span>]]);</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; <span class="number">1</span>&lt;&lt;i&lt; <span class="built_in">n</span>; ++i)&#123;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">n</span>; ++j)&#123;</span><br><span class="line">            a[j] = <span class="built_in">rank</span>[j]+<span class="number">1</span>;</span><br><span class="line">            b[j] = j + (<span class="number">1</span>&lt;&lt;i) &gt;=<span class="built_in">n</span>? <span class="symbol">0:</span> <span class="built_in">rank</span>[j + (<span class="number">1</span>&lt;&lt;i)] + <span class="number">1</span>;</span><br><span class="line">            sa[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        radix(b,sa,<span class="built_in">rank</span>,<span class="built_in">n</span>,<span class="built_in">n</span>);</span><br><span class="line">        radix(a,<span class="built_in">rank</span>,sa,<span class="built_in">n</span>,<span class="built_in">n</span>);</span><br><span class="line">        <span class="built_in">rank</span>[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j)&#123;</span><br><span class="line">            <span class="built_in">rank</span>[sa[j]] = <span class="built_in">rank</span>[sa[j-<span class="number">1</span>]] + (a[sa[j-<span class="number">1</span>]] != a[sa[j]] || b[sa[j-<span class="number">1</span>]] != b[sa[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> duplicate_substr(string str)</span><br><span class="line">&#123;</span><br><span class="line">    string rev;</span><br><span class="line">    static <span class="built_in">int</span> s[<span class="built_in">MAX</span>],sa[<span class="built_in">MAX</span>],<span class="built_in">rank</span>[<span class="built_in">MAX</span>],h[<span class="built_in">MAX</span>];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = str.length();</span><br><span class="line">    copy(str.begin(),str.end(),s);</span><br><span class="line">    suffix_array(s,sa,<span class="built_in">n</span>,<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">n</span>; ++i)</span><br><span class="line">        <span class="built_in">rank</span>[sa[i]] = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> ans1 =<span class="number">0</span>,pos1 = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; ++i)&#123;</span><br><span class="line">        k = k==<span class="number">0</span>? <span class="symbol">0:</span> k - <span class="number">1</span>;</span><br><span class="line">        while(<span class="built_in">rank</span>[i] &gt; <span class="number">0</span> &amp;&amp; s[i + k] == s[sa[<span class="built_in">rank</span>[i] - <span class="number">1</span>] + k]) ++k;</span><br><span class="line"> </span><br><span class="line">        h[<span class="built_in">rank</span>[i]] = k;</span><br><span class="line">        <span class="built_in">if</span>(h[<span class="built_in">rank</span>[i]] &gt; ans1)&#123;</span><br><span class="line">            ans1 = h[<span class="built_in">rank</span>[i]];</span><br><span class="line">            pos1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.substr(pos1,ans1).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候直接调用duplicate_substr()，传入字符串即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="机试" scheme="https://cloudqht.github.io/categories/%E6%9C%BA%E8%AF%95/"/>
    
    
      <category term="字符串" scheme="https://cloudqht.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://cloudqht.github.io/2019/02/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://cloudqht.github.io/2019/02/17/git常用命令/</id>
    <published>2019-02-17T04:17:38.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">//初始化本地git环境</span></span><br><span class="line">git clone XXX<span class="comment">//克隆一份代码到本地仓库</span></span><br><span class="line">git pull <span class="comment">//把远程库的代码更新到工作台</span></span><br><span class="line">git pull --rebase origin master <span class="comment">//强制把远程库的代码跟新到当前分支上面</span></span><br><span class="line">git fetch <span class="comment">//把远程库的代码更新到本地库</span></span><br><span class="line">git add . <span class="comment">//把本地的修改加到stage中</span></span><br><span class="line">git commit -<span class="keyword">m</span> 'comments here' <span class="comment">//把stage中的修改提交到本地库</span></span><br><span class="line">git push <span class="comment">//把本地库的修改提交到远程库中</span></span><br><span class="line">git branch -r/-a <span class="comment">//查看远程分支/全部分支</span></span><br><span class="line">git checkout master/branch <span class="comment">//切换到某个分支</span></span><br><span class="line">git checkout -b <span class="keyword">test</span> <span class="comment">//新建test分支</span></span><br><span class="line">git checkout -<span class="keyword">d</span> <span class="keyword">test</span> <span class="comment">//删除test分支</span></span><br><span class="line">git <span class="keyword">merge</span> master <span class="comment">//假设当前在test分支上面，把master分支上的修改同步到test分支上</span></span><br><span class="line">git <span class="keyword">merge</span> tool <span class="comment">//调用merge工具</span></span><br><span class="line">git stash <span class="comment">//把未完成的修改缓存到栈容器中</span></span><br><span class="line">git stash <span class="keyword">list</span> <span class="comment">//查看所有的缓存</span></span><br><span class="line">git stash pop <span class="comment">//恢复本地分支到缓存状态</span></span><br><span class="line">git blame someFile <span class="comment">//查看某个文件的每一行的修改记录（）谁在什么时候修改的）</span></span><br><span class="line">git status <span class="comment">//查看当前分支有哪些修改</span></span><br><span class="line">git <span class="keyword">log</span> <span class="comment">//查看当前分支上面的日志信息</span></span><br><span class="line">git diff <span class="comment">//查看当前没有add的内容</span></span><br><span class="line">git diff --cache <span class="comment">//查看已经add但是没有commit的内容</span></span><br><span class="line">git diff HEAD <span class="comment">//上面两个内容的合并</span></span><br><span class="line">git reset --hard HEAD <span class="comment">//撤销本地修改</span></span><br><span class="line">echo <span class="variable">$HOME</span> <span class="comment">//查看git config的HOME路径</span></span><br><span class="line">export <span class="variable">$HOME</span>=/c/gitconfig <span class="comment">//配置git config的HOME路径</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="git" scheme="https://cloudqht.github.io/categories/git/"/>
    
    
      <category term="git常用命令" scheme="https://cloudqht.github.io/tags/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>BFS&amp;DFS</title>
    <link href="https://cloudqht.github.io/2018/10/04/BFS-DFS/"/>
    <id>https://cloudqht.github.io/2018/10/04/BFS-DFS/</id>
    <published>2018-10-04T15:50:28.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS（Breadth-First-Search-广度优先搜索"><a href="#BFS（Breadth-First-Search-广度优先搜索" class="headerlink" title="BFS（Breadth-First-Search,广度优先搜索)"></a>BFS（Breadth-First-Search,广度优先搜索)</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>visited[MAX_VERTEX_NUM]<span class="comment">;</span></span><br><span class="line">void <span class="keyword">BFSTraverse(Graph </span>G)&#123;</span><br><span class="line">for(i=<span class="number">0</span><span class="comment">;i&lt;G.vexnum;i++)&#123;</span></span><br><span class="line">visited[i]=FALSE<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">InitQueue(Q)<span class="comment">;</span></span><br><span class="line">for(i=<span class="number">0</span><span class="comment">;i&lt;G.vexnum;i++)</span></span><br><span class="line">if(!visited[i])</span><br><span class="line"><span class="keyword">BFS(G,i);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">void </span><span class="keyword">BFS(Graph </span>G, int v)&#123;</span><br><span class="line">visit(v)<span class="comment">;</span></span><br><span class="line">visited[v]=TRUE<span class="comment">;</span></span><br><span class="line">Enqueue(Q,v)<span class="comment">;</span></span><br><span class="line">while(!isEmpty(Q))&#123;</span><br><span class="line">Dequeue(Q,v)<span class="comment">;</span></span><br><span class="line">for(w=FirstNeighbor(G,v)<span class="comment">;w&gt;=0;w=NextNeighbor(G,V,W))&#123;</span></span><br><span class="line">if(!isvisited(w))</span><br><span class="line">visit(w)<span class="comment">;</span></span><br><span class="line">visited[w]=TRUE<span class="comment">;</span></span><br><span class="line">Enqueue(Q,w)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS（Depth-First-Search-深度优先搜索"><a href="#DFS（Depth-First-Search-深度优先搜索" class="headerlink" title="DFS（Depth-First-Search,深度优先搜索)"></a>DFS（Depth-First-Search,深度优先搜索)</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br><span class="line">void DFSTraverse(Graph G)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">v</span>=0;v&lt;G.vexnum;++v)</span><br><span class="line">visited[v]=<span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">v</span>=0;v&lt;G.vexnum;++v)</span><br><span class="line"><span class="keyword">if</span>(!visited[v])</span><br><span class="line">DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line">void DFS(Graph G, int v)&#123;</span><br><span class="line">visit(v);</span><br><span class="line">visited[v]=<span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">w</span>=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[w])</span><br><span class="line">DFS(G,w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFS（Breadth-First-Search-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS（Breadth-First-Search-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS（Breadth-First-Search,广度优先搜
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cloudqht.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树及其进化（平衡二叉树）</title>
    <link href="https://cloudqht.github.io/2018/09/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%8A%E5%85%B6%E8%BF%9B%E5%8C%96%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/"/>
    <id>https://cloudqht.github.io/2018/09/26/二叉排序树及其进化（平衡二叉树）/</id>
    <published>2018-09-26T15:14:33.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树（二叉查找树）"><a href="#二叉排序树（二叉查找树）" class="headerlink" title="二叉排序树（二叉查找树）"></a>二叉排序树（二叉查找树）</h1><p><strong>特点：左子树值&lt;结点值&lt;右子树值，其中序遍历序列为递增有序序列</strong> </p><ul><li><h2 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h2><h3 id="二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。"><a href="#二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。" class="headerlink" title="二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。"></a><code>二叉排序树作为一种动态集合，其特点是树的结构通常不是一次生成的，而是在查找过程中当树中不存在关键字等于给定值的结点时再进行插入。插入的新结点一定是某个叶结点。</code></h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int BST_Insert(BiTree &amp;<span class="literal">T</span>, KeyType k)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="literal">T</span>=(BiTree)malloc(sizeof(BSTNode));</span><br><span class="line"><span class="literal">T</span>-&gt;key=k;</span><br><span class="line"><span class="literal">T</span>-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="literal">T</span>-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="literal">T</span>-&gt;key)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;<span class="literal">T</span>-&gt;key)</span><br><span class="line"><span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;lchild, k);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;rchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉排序树的建立"><a href="#二叉排序树的建立" class="headerlink" title="二叉排序树的建立"></a>二叉排序树的建立</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//用关键字数组str[]建立一个二叉排序树</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">BST_Insert(T,str[i++]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉排序树的非递归查找-类比线性表的二分查找"><a href="#二叉排序树的非递归查找-类比线性表的二分查找" class="headerlink" title="二叉排序树的非递归查找(类比线性表的二分查找)"></a>二叉排序树的非递归查找(类比线性表的二分查找)</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//查找函数返回指向关键字值为key的结点指针，若不存在则返回<span class="literal">NULL</span></span><br><span class="line">BSTNode *BST_Search(BiTree <span class="literal">T</span>, Elemtype key, BSTNode *&amp;p)&#123; </span><br><span class="line">p=<span class="literal">NULL</span>;//p指向被查找结点的双亲，用于插入或删除操作</span><br><span class="line"><span class="keyword">while</span>(key!=<span class="literal">T</span>-&gt;data&amp;&amp;<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">p=<span class="literal">T</span>;</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="literal">T</span>-&gt;data)</span><br><span class="line"><span class="literal">T</span>=<span class="literal">T</span>-&gt;lchild;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="literal">T</span>=<span class="literal">T</span>-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">T</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="判断给定的二叉树是否是二叉排序树"><a href="#判断给定的二叉树是否是二叉排序树" class="headerlink" title="判断给定的二叉树是否是二叉排序树"></a>判断给定的二叉树是否是二叉排序树</h2><h3 id="中序遍历序列为递增有序序列的二叉树即为二叉排序树。"><a href="#中序遍历序列为递增有序序列的二叉树即为二叉排序树。" class="headerlink" title="中序遍历序列为递增有序序列的二叉树即为二叉排序树。"></a><code>中序遍历序列为递增有序序列的二叉树即为二叉排序树。</code></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KeyType <span class="attribute">predt</span>=-65535;</span><br><span class="line"></span><br><span class="line">int JudgeBST(BiTree T)&#123;</span><br><span class="line">int b1,b2;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">T</span>==NULL)</span><br><span class="line">return 1;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="attribute">b1</span>=JudgeBST(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">b1</span>==0||T-&gt;data&lt;predt)</span><br><span class="line">return 0;</span><br><span class="line"><span class="attribute">predt</span>=T-&gt;data;</span><br><span class="line"><span class="attribute">b2</span>=JudgeBST(T-&gt;rchild);</span><br><span class="line">return b2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树是二叉排序树的演变与进化。 </p><p>二叉排序树在结点插入的顺序不同时，性能可能有所不同。 </p><p>举个极端例子，当用一个顺序序列建立二叉排序树时，结点的数量等于二叉树的高。此时查询一个结点的时间复杂度与单链表相同，为O(n)。这与我们想要的时间复杂度O($\log_2 n$)相距甚远。 </p><p>由于二叉排序树的性能与其高度息息相关，为避免出现性能下降的情况，则在插入结点时要充分利用其高度，避免其增长过快。由此，平衡二叉树诞生了。 </p><p>平衡二叉树（AVL树）保证在插入和删除结点后，二叉树任意节点的左、右子树高度差绝对值不超过1。定义结点左右子树的高度差为结点的平衡因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉排序树（二叉查找树）&quot;&gt;&lt;a href=&quot;#二叉排序树（二叉查找树）&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树（二叉查找树）&quot;&gt;&lt;/a&gt;二叉排序树（二叉查找树）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;特点：左子树值&amp;lt;结点值&amp;lt;右子树值
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的鉴别</title>
    <link href="https://cloudqht.github.io/2018/09/26/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%89%B4%E5%88%AB/"/>
    <id>https://cloudqht.github.io/2018/09/26/完全二叉树的鉴别/</id>
    <published>2018-09-26T10:38:52.000Z</published>
    <updated>2020-07-25T06:15:37.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用完全二叉树的性质鉴别"><a href="#利用完全二叉树的性质鉴别" class="headerlink" title="利用完全二叉树的性质鉴别"></a>利用完全二叉树的性质鉴别</h2><h3 id="完全二叉树的1-n结点与满二叉树相同"><a href="#完全二叉树的1-n结点与满二叉树相同" class="headerlink" title="完全二叉树的1-n结点与满二叉树相同"></a><code>完全二叉树的1-n结点与满二叉树相同</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool isComplete(BiTree T)&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//空二叉树为完全二叉树</span></span><br><span class="line">InitQueue Q;</span><br><span class="line">BiTree p;</span><br><span class="line">EnQueue(Q,T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">DeQueue(Q,p);</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">EnQueue(Q,p-&gt;lchild);</span><br><span class="line">EnQueue(Q,p-&gt;rchild);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">DeQueue(Q,p);</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用完全二叉树的性质鉴别&quot;&gt;&lt;a href=&quot;#利用完全二叉树的性质鉴别&quot; class=&quot;headerlink&quot; title=&quot;利用完全二叉树的性质鉴别&quot;&gt;&lt;/a&gt;利用完全二叉树的性质鉴别&lt;/h2&gt;&lt;h3 id=&quot;完全二叉树的1-n结点与满二叉树相同&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的建立</title>
    <link href="https://cloudqht.github.io/2018/09/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://cloudqht.github.io/2018/09/25/二叉树的建立/</id>
    <published>2018-09-25T15:56:19.000Z</published>
    <updated>2020-07-25T06:15:37.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由先序遍历序列和中序遍历序列确定二叉树"><a href="#由先序遍历序列和中序遍历序列确定二叉树" class="headerlink" title="由先序遍历序列和中序遍历序列确定二叉树"></a>由先序遍历序列和中序遍历序列确定二叉树</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A,B数组存放先序和中序结点的data</span></span><br><span class="line"><span class="comment">//l1,l2,h1,h2分别为先序和中序的第一和最后一个结点下标</span></span><br><span class="line">BiTree PreInCreate(Elemtype A[], Elemtype B[], l1, h1, l2, h2)&#123; </span><br><span class="line"><span class="comment">//建立根节点</span></span><br><span class="line">BiTNode root = new BiTNode;<span class="comment">//c写法为(BiTNode*)malloc(sizeof(BiTNode));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span><span class="keyword">data</span>=A[l1];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到先序遍历头结点A[l1]结点在中序遍历中的位置</span></span><br><span class="line"><span class="function"><span class="title">for</span>(int i=l2;B[i]!=root-&gt;</span><span class="keyword">data</span>;i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右子树长度</span></span><br><span class="line">int llen=i-l2;</span><br><span class="line">int rlen=h2-i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归建立左右子树，若len=0,则左右结点置为NULL</span></span><br><span class="line"><span class="keyword">if</span>(llen)</span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>lchild=PreInCreate(Elemtype A[], Elemtype B[],</span><br><span class="line"> l1+<span class="number">1</span>, l1+llen, l2, l2+llen-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>lchild=NULL;</span><br><span class="line"><span class="keyword">if</span>(rlen)</span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>rchild=PreInCreate(Elemtype A[], Elemtype B[],</span><br><span class="line"> h1-rlen+<span class="number">1</span>, h1, h2-rlen+<span class="number">1</span>, h2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">root</span>-&gt;</span>rchild=NULL;</span><br><span class="line"></span><br><span class="line">return root; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;由先序遍历序列和中序遍历序列确定二叉树&quot;&gt;&lt;a href=&quot;#由先序遍历序列和中序遍历序列确定二叉树&quot; class=&quot;headerlink&quot; title=&quot;由先序遍历序列和中序遍历序列确定二叉树&quot;&gt;&lt;/a&gt;由先序遍历序列和中序遍历序列确定二叉树&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cloudqht.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://cloudqht.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
